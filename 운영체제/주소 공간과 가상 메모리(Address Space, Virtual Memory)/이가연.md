# 주소 공간과 가상 메모리


![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/1183c2a1-aae1-4ca0-9aa2-4e377889a6df)

초기 컴퓨터는 하나의 물리 메모리에 하나의 프로세스를 저장하였다. (1:1) <br>
그러나 최근에는 여러 프로세스를 실행하는 멀티 프로세싱이 두각되면서 메모리의 개선이 요구되었다. <br>
따라서 시분할 기법을 이용해 한 메모리에서 여러 프로세스를 처리하도록 다음과 같이 메모리 구조를 바꾸게 되었다. <br>

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/1200decd-47fb-47fa-aa5a-fe0529aa3665)

다음과 같은 메모리에서 프로세스 A가 실행중이고 프로세스 B,C는 준비큐에서 대기중이다. <br>
하나의 메모리 공간에서 여러 개의 프로세스가 전환이 되므로 활용성과 효율성이 증가하게 되었다. <br>
단, 프로세스끼리 영역을 침범할 수 있는 문제는 여전히 존재한다. <br>
이와 같은 위험에 대비하기 위해 OS는 사용자에게 사용하기 쉬운 메모리 개념을 만들어야한다. 이를 **주소공간**이라 부른다. <br>

>**시분할(Time Sharing/Round Robin)**<br>
>하나의 CPU는 같은 시점에서 여러 개의 작업을 동시에 수행할 수 없기 때문에,<br>
> CPU의 전체 사용시간을 작은 작업 시간량으로 쪼개어 그 시간량 동안만 번갈아가면서 CPU를 할당하여 각 작업을 처리합니다.<br>
> 다중프로그래밍 방식과 결합하여 모든 작업이 동시에 진행되는 것처럼 대화식 처리가 가능합니다.<br>
> 중요한 점은 **동시에 실행되는 것처럼 보일 뿐**, 절대 동시에 실행되고 있는 건 아니라는 점입니다. <br>


## 주소 공간

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/827ca84f-cfc0-4c25-a709-358b5f1d252d)

앞서 메모리 구조는 **코드, 힙, 스택** 공간으로 나뉜다 설명했다. <br>
코드는 정적이기 때문에 (변하지 않죠.) 메모리가 늘어날 이유가 없으므로 상단에 위치한다. <br>
힙은 FIFO 구조로 위에서 아래로, 스택은 LIFO 구조로 아래에서 위로 확장한다. <br>


