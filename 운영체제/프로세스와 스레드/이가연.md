# 프로세스와 쓰레드

## 프로세스
![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/85ad49c2-a47d-4e97-8e8a-ffb933918d88)

프로세스는 쉽게 말해 **현재 실행중인 프로그램**이다.<br>
디스크에 있는 프로그램이 메모리로 로드되어 CPU 자원을 할당 받으 프로세스라고 한다.<br>
스택, 힙, 데이터, 코드로 구성된다.

### 프로세스 문맥(Process Context)
Process의 특정 시점의 상태를 표현하는 정보이다.

### 프로그램 코드
프로세스의 실행을 위해 필요한 명령어와 데이터가 포함된 프로그램 코드이며, 프로세스가 실행될 때 메모리에 로드된다.

### 프로세스 상태(Process State)
![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/e1a5f824-aeca-4d77-8a06-90dbab4773c2)

프로세스의 상태는 프로세스가 실행됨에 따라 달라진다. 
 
1. **New** : 프로세스가 처음 생성된 상태
2. **Ready** : 프로세스가 CPU에 할당되기를 기다리는 상태 (메모리 등 다른 조건을 모두 만족하고)
3. **Running** : 프로세스가 할당되어 CPU를 잡고 명령을 수행 중인 상태
4. **Waiting** : 프로세스가 어떠한 이벤트가 발생하기를 기다리는 상태. CPU를 할당해도 당장 명령을 수행할 수 없는 상태.
5. **Terminated** : 프로세스가 실행을 마쳤을 때. 아직 완전히 프로세스가 제거되진 않은 상태.

### PCB(Process Control Block)
![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/7ef57744-8855-443d-9d12-f1d21673afda)

PCB(Process Control Block)는 운영체제가 각 프로세스를 관리하기 위해 프로세스별로 보유하고 있는 자신의 정보 묶음 단위(자료구조)이다.<br>
이 블록은 프로세스의 상태, 프로그램 카운터(PC), 레지스터 상태, 할당된 자원 정보 등의 정보를 포함한다.<br>
PCB는 프로세스의 상태 전이, 스케줄링, 자원 할당 등의 작업에 사용된다.<br>

### 문맥교환(Context Switch)
Context Switch(문맥 교환)는 프로세스가 실행되다가 인터럽트가 발생해 CPU를 한 프로세스에서 다른 프로세스로 넘겨주는 과정이다.<br>
운영체제는 CPU를 내어주는 프로세스의 상태를 그 프로세스의 PCB에 저장하고, CPU를 새롭게 얻는 프로세스의 상태를 PCB에서 읽어온다. <br>
즉, CPU입장에서 Context는 PCB이기 때문에 PCB 정보가 바뀌는 것이 Context Switch이다.  <br>

## 프로세스 스케줄링(Process Scheduling)
프로세스 스케줄링은 운영 체제에서 다중 프로세스가 실행되는 환경에서 CPU의 사용을 조절하고 관리하는 것을 말한다.<br>
이는 여러 프로세스가 경쟁적으로 CPU 자원을 요청하고, 이를 적절히 할당하여 시스템의 성능을 최적화한다.

### 주소공간
각 프로세스는 독립된 가상 주소 공간을 가지며 다른 프로세스와 격리되어 있다.<br>
메모리간의 충돌을 방지한다. <br>
<hr>

### 쓰레드
프로세스 내에서 실행되는 독립적인 실행 흐름이다. **CPU 수행의 기본 단위**라고도 한다. <br>
한 프로세스가 하나의 스레드를 이용하여 한 번에 한 작업만 수행하는 것은 싱글 스레드(Single thread), <br>
한 프로세스가 여러 스레드로 동시에 여러 작업을 수행하는 것은 멀티 스레드(Multi thread)라고 한다.<br>

#### 멀티 스레드
프로세서가 여러 개인 경우 멀티 스레드를 통해 병렬성을 높일 수 있고<br>
프로세서가 하나인 경우엔 멀티 스레드를 통해 동시성(Concurrency)을 높일 수 있다.<br>

**장점**

1. **응답성(Responsiveness)**
 
싱글 스레드인 경우, 작업이 끝나기 전까지 사용자에게 응답하지 않는다. 반면 멀티스레드인 경우 작업을 분리해서 수행하므로 실시간으로 사용자에게 응답할 수 있다. 
 
2. **자원 공유(Resource sharing)**
 
프로세스는 오직 공유 메모리나 메시지 패싱을 이용해서 자원을 공유할 수 있지만, 스레드는 자신이 속한 프로세스 내의 스레드들과 메모리나 자원을 공유하여 효율적으로 사용할 수 있다.
 
3. **경제성(Economy)**
 
프로세스를 새로 생성하는 비용보다 스레드를 새로 생성하는 게 훨씬 싸다. 그리고 Context switching의 오버헤드 또한 스레드가 더 경제적이다. 실제로 Solaris에서 프로세스 생성은 스레드 생성보다 30배 느리고, switching은 5배 느리다. 
 
4. **확장성(Scalability)**
 
싱글 스레드인 경우 한 프로세스는 오직 한 프로세서에서만 수행 가능하다. 반면 멀티 스레드인 경우 한 프로세스를 여러 프로세서에서 수행할 수 있으므로 훨씬 효율적이다. 






   
출처: https://rebro.kr/172 [Rebro의 코딩 일기장:티스토리]


