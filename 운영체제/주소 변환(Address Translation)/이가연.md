# 주소 변환

가상화 메모리는 프로세스의 가상 주소를 담은 주소 공간을 이용해 물리 메모리의 용량의 한계를 극복하는 기술이라 하였다. <br>
이때 **주소 공간(CPU)의 가상 주소를 물리 메모리(DRAM)의 물리 주소로 변환**하는 것을 주소 변환이라 한다. <br>
따라서 모든 메모리 참조에서 프로그램 메모리 참조를 실제 주소로 변환하기 위해 하드웨어가 주소 변환을 수행하게 된다. <br>
메모리 가상화는 하드웨어의 힘만으로는 불가능하며, **OS의 개입이 불가피**하다. <br>
운영체제는 **메모리의 빈 공간과 사용 중인 공간을 항상 알고 있어야** 하고, 메모리 사용을 제어하고 관리해야한다. <br>

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/6552ecb5-9a41-40d0-af1e-e9d4715812cf)



왼쪽 사진의 관점에서 주소 공간은 0부터 시작해서 최대 16KB까지이다. <br>
하지만 우리는 메모리의 가상화를 위해서 오른쪽 사진과 같이 물리 메모리의 특정 위치로 이를 재배치하고 싶다. <br>
가장 대표적인 재배치 방법은 베이스와 바운드 레지스터를 이용한 동적 재배치 방법이다. 

## 동적 재배치 

- base 레지스터: 재배치 후 주소 공간의 시작 부분
- bound 레지스터: 주소 공간 크기

base와 bound는 우리가 **원하는 위치에 주소 공간을 배치**할 수 있도록 보장한다. <br>
그리고 배치와 동시에 **프로세스가 오직 자신의 주소 공간에만 접근**하는 것을 보장한다. <br>
따라서 물리 주소는 다음과 같은 수식으로 변환된다. <br>

```
physical address = virtual address + base
```
그렇다면 bound 레지스터는 어디에 사용되는가, <br>
bound 레지스터는 보호를 지원하기위해 사용된다. <br>

```
0 <= virtual address < bound
```
다음과 같은 수식을 이용해 만약 바운드보다 큰 주소 또는 음수인 가상주소를 접근하려고하면 CPU는 예외를 발생시키고 프로세스를 종료시킬 것이다. <br>
즉 bound 레지스터는 주소 공간의 크기이자 주소 공간의 마지막 물리주소이기도 한 것이다. <br>




