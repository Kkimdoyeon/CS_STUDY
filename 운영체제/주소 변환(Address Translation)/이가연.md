# 주소 변환

가상화 메모리는 프로세스의 가상 주소를 담은 주소 공간을 이용해 물리 메모리의 용량의 한계를 극복하는 기술이라 하였다. <br>
이때 **주소 공간(CPU)의 가상 주소를 물리 메모리(DRAM)의 물리 주소로 변환**하는 것을 주소 변환이라 한다. <br>
따라서 모든 메모리 참조에서 프로그램 메모리 참조를 실제 주소로 변환하기 위해 하드웨어가 주소 변환을 수행하게 된다. <br>
메모리 가상화는 하드웨어의 힘만으로는 불가능하며, <a name="OS의역할">**OS의 개입이 불가피**</a>하다. <br>
운영체제는 **메모리의 빈 공간과 사용 중인 공간을 항상 알고 있어야** 하고, 메모리 사용을 제어하고 관리해야한다.<br>

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/6552ecb5-9a41-40d0-af1e-e9d4715812cf)



왼쪽 사진의 관점에서 주소 공간은 0부터 시작해서 최대 16KB까지이다. <br>
하지만 우리는 메모리의 가상화를 위해서 오른쪽 사진과 같이 물리 메모리의 특정 위치로 이를 재배치하고 싶다. <br>
가장 대표적인 재배치 방법은 베이스와 바운드 레지스터를 이용한 동적 재배치 방법이다. 

>**재배치의 목적**<br>
>![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/fb86901e-cccc-4e80-81c4-7e303c17b16a) <br>
>OS가 메모리를 재배치하지 않고 항상 고정된 위치에 할당한다면, 즉 메모리의 파티션을 미리 나눈다면 <br>
>각 파티션별로 프로세스 대기큐가 생성되고 노는 파티션이 생길 것이다. -> 비효율 <br>
>하지만 재배치가 가능하다면 프로세스 크기에 따라 적절한 파티션에 배치가 가능해 <br>
>파티션마다 대기큐가 발생하는것이 아닌 싱글큐로 배치가 가능해진다. 

## 동적 재배치 

- **base 레지스터**: 재배치 후 주소 공간의 시작 부분
- **bound(limit) 레지스터**: 주소 공간 크기

base와 bound는 우리가 **원하는 위치에 주소 공간을 배치**할 수 있도록 보장한다. <br>
프로그램 실행 시에 운영체제가 프로그램이 탑재될 물리 메모리 위치를 결정하고 base 레지스터를 그 주소로 지정한다. <br>
따라서 물리 주소는 다음과 같은 수식으로 변환된다. <br>

```
physical address(하드웨어) = virtual address(프로세스) + base(운영체제)
```
그렇다면 bound 레지스터는 어디에 사용되는가, <br>
bound 레지스터는 보호를 지원하기위해 사용된다. <br>
프로세서는 먼저 메모리 참조가 합법적인가를 확인하기 위해 가상 주소가 바운드 안에 있는지 확인한다. <BR>
이 과정에서 **프로세스가 오직 자신의 주소 공간에만 접근**하는 것을 보장한다. <br>

```
0 <= virtual address < bound
```
다음과 같은 수식을 이용해 만약 바운드보다 큰 주소 또는 음수인 가상주소를 접근하려고하면 CPU는 예외를 발생시키고 프로세스를 종료시킬 것이다. <br>
즉 bound 레지스터는 주소 공간의 마지막 물리주소이자 보호의 역할을 하는 것이다. <br>

>- 베이스와 바운드 쌍은 우리가 원하는 위치에 주소 공간을 배치할 수 있게 하며,<br> 배치와 동시에 프로세스가 **오직 자신의 주소 공간에만 접근**한다는 것을 보장한다.
>- 프로그램 실행 시에 운영체제가 프로그램이 탑재될 물리 메모리 위치를 결정하고 베이스 레지스터를 그 주소로 지정한다.
>- 주소의 재배치는 실행 시에 일어나고, 프로세스가 실행을 시작한 이후에도 주소 공간을 이동할 수 있다. ->동적 재배치

## MMU

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/7c7ddbb1-8db4-46c0-9dab-fc9e98bad6bd) <br>
LAS -> PAS

MMU는 주소변환을 도와주는 하드웨어 장치이다. <br>
```
virtual address + base < bound
```
다음과 같이 가상주소와 base 레지스터의 합이 bound 레지스터 범위 안에 들어있으면 물리 주소로 변환해주고, <br>
범위를 벗어나면 예외처리를 해준다. 

## OS의 개입 
[주소변환에 있어 OS의 개입은 불가피하다 했다.](#OS의역할) <br>
운영체제가 주소변환에 어떻게 기여하는지 알기 위해 우선 주소변환을 위해 필요한 요소들을 검토해보자. 

- 베이스/바운드 레지스터
- 가상 주소를 변환하고 범위 안에 있는지 검사하는 능력
- 베이스/바운드를 갱신하기 위한 특권 명령어
- 예외 핸들러 등록을 위한 특권 명령어
- 예외 발생 가능

운영체제가 가상메모리를 지원하기 위해 운영체제가 개입해야 하는 순간은 3가지이다. 

**1) 프로세스가 생성**
  - 프로세스가 생성될 때 운영체제는 주소 공간을 위한 여유 공간을 확보해야 한다.
  - 이 여유 공간은 물리 메모리의 free list를 뜻한다. <br>
**2) 프로세스가 종료**
  - 프로세스가 종료할 때 프로세스가 사용하던 메모리를 회수하여 다른 프로세스나 운영체제가 사용할 수 있게 해야한다. <br>
**3) 프로세스간 문맥교환**
  - 문맥교환시 운영체제는 프로세스의 베이스와 바운드 쌍을 저장하고 복원해야한다.
  - 이 저장과 갱신은 [PCB](https://github.com/dlrkdus/CS_STUDY/blob/main/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/PCB%EC%99%80%20Context%20Switching/%EC%9D%B4%EA%B0%80%EC%97%B0.md)에 이루어진다.
  - 예를 들어, Process A 가 실행하는 도중에 문맥교환이 발생하면, Process A의 base 레지스터와 bound 레지스터를 PCB에 저장을 한다.
  - 그리고 프로세스가 종료될 때, 다시 PCB에서 저장된 Process A의 base 레지스터와 bound 레지스터를 가져와서 다시 실행한다. <br>
**4) 예외처리**

## 문제점

- 동적 재배치를 통해 할당된 영역은 내부 공간이 사용되지 않기 때문에 **내부 단편화(프레그멘테이션)**가 발생하여 낭비된다.
- 주소 공간과 수식 계산을 위한 추가 메모리
- 주소 접근시 오버헤드

가장 큰 문제인 내부 단편화와 물리메모리의 이용률을 올리기 위한 기법인 **세그멘테이션**은 다음 페이지에서 설명한다. 


#### 출처
https://rxdcxdrnine.tistory.com/25





