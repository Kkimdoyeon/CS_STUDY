# 가상 메모리와 요구페이징, 페이지 교체

# 가상메모리

### 가상메모리란?

운영체제는 메모리가 실제 메모리보다 많아 보이게 하는 기술인 가상 메모리를 제공합니다. 

이로 인해 우리는 물리적 메모리 한계에도 불구하고 더 많은 양을 가진 프로그램들을 실행시킬 수 있습니다. 

가상 메모리는 시스템이 프로그램을 실행시키는데 최소한 얼마만큼의 메모리가 필요한가에 대한 접근 방식으로, 실행에 필요한 일부분만 메모리에 로드하고 나머지는 디스크에 두고서 필요할 때마다 교체하면서 쓰는 방식으로 구현됩니다. 

### 가상메모리 장점

1. 메인 메모리를 하드 디스크의 캐시로 처리하여 더 넓은 메모리 공간을 제공합니다. 즉, 임시 데이터를 하드 디스크 드라이브에 저장하고 필요에ㅔ 따라 기본 메모리로 가져올 수도 있습니다. 
2. 메모리 크기의 제약으로부터 자유로워졌고 사용자 프로그램이 실행에 필요한 최소 크기의 메모리만을 올라가져 있기 때문에 더 많은 프로그램을 동시 수행 가능해졌습니다. 
3. 추가 권한 비트를 사용하여 각 프로세스에 메모리에 대한 제한된 액세스 권한을 부여하여 메모리를 보호합니다. OS는 권한 비트를 확인하여 한 프로세스가 다른 프로세스의 메모리 공간을 손상시키지 않도록 할 수 있습니다. 

# 요구 페이징

### 요구 페이징 이란?

필요한 부분만 요청이 있을 때 물리적 메모리에 페이지 단위로 적재하는 방법을 요구 페이징이라고 합니다. 

특정 페이지에 대해 CPU 요청이 들어오면 해당 PAGE를 메모리에 적재합니다. 

### 요구 페이징 예시

OS에 실행 중인 모든 프로그램을 저장하는데 300MB의 메모리가 필요하다고 가정하고, 현재 RAM에 저장된 사용 가능한 물리적 메모리는 50MB라고 가정합니다. 

- OS는 250MB의 가상 메모리를 설정하고 VMM(Virtual Memory Manager)이라는 프로그램을 사용하여 250MB를 관리합니다.
- 이 경우 VMM은 필요한 추가 메모리를 저장하기 위해 250MB 크기의 파일을 디스크에 생성합니다.
- 이제 OS는 RAM에 저장된 300MB의 실제 메모리를 고려하므로 50MB의 공간만 사용할 수 있더라도 메모리 주소 지정을 계속합니다.
- 50MB의 실제 메모리 공간만 사용할 수 있더라도 300MB의 메모리를 관리하는 것이 VMM의 역할입니다.

요구 페이징은 페이지 테이블에서 해당 PAGE가 메모리에 있는지를 나타내는 유/무효 비트를 사용합니다. 

비트가 무효인 경우, 페이지가 물리적 메모리에 없다는 것으로 페이지 부재가 발생합니다. 

### 페이지 부재 처리 과정

- CPU가 특정 페이지를 접근하여 페이지 테이블에서 유/무효 상태를 확인합니다.
- 페이지가 무효 상태일 때, MMU에서 페이지 부재 트랩이 발생합니다.
- 디스크에서 해당 페이지를 빈 프레임에 적재하고 페이지 테이블을 업데이트 합니다.
- 트랩에 의해 중단되었던 명령을 다시 수행합니다.

# 페이지 교체 알고리즘

### 페이지 교체란?

페이지 부재가 발생하면 요청된 페이지를 디스크에서 메모리로 가져옵니다. 이 때, 물리적 메모리에 공간이 부족할 수 있습니다. 

그럴 경우에는 메모리에 올라와 있는 디스크를 옮겨서 메모리 공간을 확보해야하는 데 이를 페이지 교체라고 합니다. 

어떤 페이지를 교체할 것이냐를 결정하는 알고리즘이 필요합니다. 

좋은 알고리즘은 최대한 페이지 부재가 적게 일어나도록 하여 쓰레싱을 방지하는 것을 목표로 합니다. 

여러 알고리즘 중 가장 널리 알려진 알고리즘들을 살펴보겠습니다. 

### 종류

- FIFO(First-In, First-Out) : 메모리에 적재된 것 중 가장 먼저 들어온 페이지를 교체합니다. 큐 방식과 동일합니다.
- LFU(Least Frequently Used Algorithm) : 과거에 참조 횟수가 가장 적은 페이지를 내보내는 알고리즘입니다. 메모리에 적재될 때부터 페이지의 횟수를 카운트하는 Incache-LFU 방식과 메모리 적재여부와 상관없이 참조 횟수를 카운트하는 Perfect-LFU 방식이 있습니다.
- LRU(Least Recently Used Algorithm) : 사용 가능성이 낮은 페이지를 우선적으로 내보냅니다. 시간직역성을 이용해 가장 오래 전에 참조가 이루어진 페이지를 내보냅니다.
- OPT(OPTimal) : 앞으로 가장 오랫동안 사용하지 않을 페이지를 내린다는 최적 페이지 알고리즘입니다. 그러나 미래에 어떤 페이지를 얼마나 사용할 것인지는 알 수 없으므로 일반 OS에서는 구현이 불가하여 실제 구현보다는 비교 연구 목적으로 사용됩니다.

📚 출처

- [https://velog.io/@wngud4950/CS운영체제OS-가상-메모리-Virtual-Memory](https://velog.io/@wngud4950/CS%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-Virtual-Memory)
- [Page Fault Handling in Operating System](https://www.javatpoint.com/page-fault-handling-in-operating-system)
- [Virtual Memory](https://medium.com/@mahmoudabdalghany/virtual-memory-b2c77308c9fd)
- [The Difference Between Virtual Memory and Swap Space](https://www.baeldung.com/cs/virtual-memory-vs-swap-space)
- [Virtual Memory in OS: What is, Demand Paging, Advantages](https://www.guru99.com/virtual-memory-in-operating-system.html)