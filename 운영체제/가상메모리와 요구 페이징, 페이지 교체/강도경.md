# 가상 메모리

## 가상 메모리 의미

- **기존 문제**
    - 프로세스가 실행되는 코드의 전체를 메모리에 로드해야 함
    - 메모리 용량보다 더 큰 프로그램은 실행시킬 수 없음
    - 실제로는 코드의 일부에서만 대부분의 시간을 사용하고 프로세스는 특정 순간에는 항상 작은 양의 주소 공간을 사용했기 때문에 이러한 방식은 매우 비효율적

<br/>
    
- **물리적 메모리 크기의 한계를 극복하기 위해 나온 기술이 가상 메모리**
    - 프로세스를 실행할 때 실행에 필요한 일부만 메모리에 로드하고 나머지는 디스크에 둠
    - 모든 데이터를 주 기억장치에 올리지 않고 필요한 것들만 올려서 사용하고 남은 것들은 보조 기억장치(HDD, SDD)에 존재하며 필요할 때 보조 기억장치에서 주 기억장치로 옮겨서 사용
    - 가상 메모리의 주소와 실제 메모리의 주소는 일치하지 않음
    - 프로세스 전체가 물리적 메모리에 있는 것 '처럼' 수행
    - 물리적 메모리가 훨씬 많이 있는 것처럼 보이게 됨
    - 메모리에 작은 양의 주소 공간만 있으면 충분히 프로세스를 수행할 수 있고 그에 따라 더 많은 프로그램을 동시에 실행할 수 있게 됨
    - 가상 메모리의 주소와 실제 메모리 주소를 1:1 대응시켜야 함
        - 이를 해결해주는 것이 MMU(Memory Managment Unit)
        - MMU는 가상 메모리 주소를 -> 실제 메모리 주소로 변환시켜주는 하드웨어
        - 모든 메모리 주소를 MMU를 거쳐 변환하는 것은 오버헤드가 큼
        - 따라서 MMU는 메모리를 일정 단위로 쪼개서 관리
            - **쪼개는 방법에 따라 페이징 기법, 세그멘테이션 기법으로 나뉨**

<br/>

# 요구 페이징

## 요구 페이징 의미

- **필요한 부분만 요청이 있을 때 물리적 메모리에 페이지 단위로 적재하는 방법**
- CPU가 요청할 때 프로세스의 데이터를 RAM에 올림
- 즉, 프로세스의 모든 데이터를 메모리에 올리지 않음
- 메모리를 더 효율적으로 사용
- 당장 실행에 필요없는 부분은 Backing Store에 저장
- 필요한 페이지만 메모리에 올리면 메모리 사용량을 줄일 수 있고 디스크 입출력 횟수도 감소시킬 수 있어 전체적인 성능 향상이 이뤄짐

<br/>

## 페이지 부재 (page fault)

### 페이지 부재 의미

- 메모리에 적재된 페이지 중 사용 페이지가 없을 때를 의미
- 시스템의 종류에 따라 약간 다를 수 있으나 대체로 빈 페이지가 하나도 없거나 미리 정한 수보다 적을때 발생
- 페이지 부재가 발생하면 해당 페이지를 가상 메모리에서 찾아야함

<br/>

## 수행 과정

1. CPU 는 물리메모리를 확인하여 페이지가 없으면 trap을 발생하여 운영체제에 알림
2. 운영체제는 CPU의 동작을 잠시 멈춤
3. 운영체제는 페이지테이블을 확인하여 가상 메모리에 페이지가 존재하는 확인하고 없으면 프로세스를 중단
4. 페이지 부재면, 현재 물리 메모리에 비어있는 프레임이 있는지 찾음 (페이지 교체 알고리즘이 사용)
5. 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화
6. 중단되었던 CPU를 다시 시작

<br/>

# 페이징 교체 알고리즘

## 페이징 교체 알고리즘 의미

- 필요한 페이지가 메모리에 없을 때 page falut가 발생하고 Backing Store에서 해당 페이지를 찾아 빈 프레임에 로딩해야 함
- **빈 프레임이 없을 경우 희생 당할 프레임(victim frame)을 고르는 알고리즘이 페이지 교체 알고리즘**
- 페이지 교체 알고리즘은 page-fault 발생 비율을 줄이는 것을 목표

<br/>

## 페이징 교체 알고리즘 종류

### FIFO(First In First Out) 알고리즘

- FIFO 알고리즘은 이름 그대로 가장 먼저 메모리에 올라온 페이지를 가장 먼저 내보내는 알고리즘
- 메모리에 적재된 것 중 가장 먼저 들어온(오래된) 페이지를 교체
- 큐 방식과 동일
- 구현이 간단하지만 성능은 좋지 않은 편
- 들어온 시간을 저장하거나 올라온 순서를 큐를 이용해 저장할 수 있음
- Belady`s Anomaly 현상이 발생할 수 있음
    - Belady`s Anomaly : 프레임의 개수가 많아져도 page-fault가 줄어들지 않고 늘어나는 현상

<br/>

### OPT(Optimal) 알고리즘

- OPT 알고리즘은 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 알고리즘
- 앞으로 가장 오랫동안 사용하지 않을 페이지를 내린다는 최적 페이지 알고리즘
- 모든 페이지 교체 알고리즘 중 page-fault 발생이 가장 적음
- 미래에 어떤 페이지를 얼마나 사용할 것인지는 알 수 없으므로 일반 OS에서는 구현이 불가하여 실제 구현보다는 비교 연구 목적으로 사용
- Belady`s Anomaly 현상이 발생하지 않음
프로세스가 앞으로 사용할 페이지를 미리 알아야함
- 실제로 구현하기 거의 불가능한 알고리즘
- 실제로 사용하기 보다는 연구 목적을 위해 사용

<br/>

### LRU(Least Recently Used) 알고리즘

- LRU 알고리즘은 가장 오랫동안 사용하지 않은 페이지를 교체하는 알고리즘
- 사용 가능성이 낮은 페이지를 우선적으로 내보냄
- 시간지역성을 이용해 가장 오래 전에 참조가 이루어진 페이지를 내보냄
- 최적 알고리즘과 비슷한 효과를 낼 수 있음
- 성능이 좋은 편
- 많은 운영체제가 채택하는 알고리즘

<br/>

### LFU(Least Frequently Used Algorithm)

- 과거에 참조 횟수가 가장 적은 페이지를 내보내는 알고리즘
- 메모리에 적재될 때부터 페이지의 횟수를 카운트하는 Incache-LFU 방식과 메모리 적재여부와 상관 없이 참조 횟수를 카운트하는 Perfect-LFU 방식있음

<br/>

### MFU(Most Frequently User) 알고리즘

- MFU 알고리즘은 LFU와 반대로 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘