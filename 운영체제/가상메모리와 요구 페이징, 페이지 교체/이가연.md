# 가상 메모리 

가상 메모리에 대해 복습해보자. <br>
우리가 사용하는 주 메모리 RAM은 대개 8GB~ 16GB이다. <br>
하지만 우리는 이러한 램의 용량보다 훨씬 큰 용량의 응용 프로그램을, 그것도 여러개씩 돌리곤 한다. <br>
분명 어떤 프로그램을 실행하려면 메모리에 적재해야하는데 **메모리의 용량보다 큰 프로그램은 어떻게 실행**되는걸까? <br>
이렇게 물리 메모리의 한계를 극복하고자 고안된 방법이 가상메모리이다. <br>
프로그램의 전체를 메모리에 적재하지 않고 **일부만 적재**해도 실행할 수 있다는 점에서 착안한 방안이다. <br>

우리는 메모리보다 훨씬 큰 용량의 디스크(보조기억장치)를 갖고 있고, <br>
주메모리와 보조메모리에 모두 접근 가능한 OS는 메모리 관리 책임을 전적으로 져 <br>
프로그램의 논리적 주소 영역에서 필요한 부분만 메모리에 적재하고 나머지 코드는 디스크에서 관리하게 된다. <br>

우리는 가상 메모리로 주메모리와 보조메모리를 하나의 메모리처럼 사용해 **물리 메모리 용량의 한계를 극복**할 수 있게 됐고, <br>
비슷한 맥락으로 여러 프로세스를 적재 가능해 **멀티 프로세싱**이 가능해졌다. <br>
또 중요한 장점이 있는데, **스와핑으로 인한 오버헤드**가 효과적으로 감소한다. <br>

>**짚고 넘어가자, 스와핑?**<br>
><img src="https://github.com/dlrkdus/CS_STUDY/assets/99721126/645edf18-c279-4960-af77-d9f798eb73c7" width="40%"><br>
>P2를 실행시키려 할 때 메모리의 용량이 부족해 실행중인 P1을 디스크로 옮기고 (swap out) <br>
>P2를 메모리에 적재시키는 것 (swap in)<br>
>극심한 비효율<br>

가상 메모리의 구현 방법으로 세그먼테이션과 페이징에 대해 배웠는데, 최근에는 대부분 페이징을 많이 사용한다. <br>
따라서 가상 메모리를 구현하기 위해선 페이징의 주요 기술인 요구 페이징과 페이지 교체 기술이 필요하다. <br>


