# 운영체제 면접 예상질문 

## 운영체제와 컴퓨터
- 운영체제와 운영체제의 역할에 대해 설명해주세요.
  
  - 운영체제는 사용자에게 편리한 인터페이스를 제공하고 시스템의 자원을 효율적으로 관리하는 소프트웨어입니다.<br>
      대표적으로 자원관리, 프로세스 관리, 메모리 관리, 입출력 관리, 파일 시스템 관리, 네트워킹 관리 등의 역할을 합니다. <br>
      
- 커널에 대해 설명해주세요.
  
  - 커널은 OS의 핵심부분으로 소프트웨어와 하드웨어의 인터페이스 역할을 합니다. <br>
    대표적인 기능으론 자원관리, 프로세스 관리, 메모리 관리, 입출력 관리, 시스템 콜 처리 등이 있습니다.

- 시스템 콜에 대해 설명해주세요.
  
  - 응용 프로그램은 하드웨어와 직접적으로 상호작용 할 수 없습니다. <br>
    시스템콜은 이러한 응용 프로그램과 하드웨어를 연결시켜주는 인터페이스 역할을 합니다. 

- 운영체제의 목적에 대해 설명해주세요

  - 운영체제는 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축을 목적으로 하고 있습니다.
 
- CPU에 대해 설명해주세요

  - 중앙처리장치이며 컴퓨터 성능의 중요한 요소입니다. 전원이 공급될 때 작동을 시작하며 명령어를 해석하여 메모리에 적재된 프로그램을 실행합니다. <br>
    CPU 코어는 산술연산장치를 사용해 데이터 처리와 연산을 수행하고 따라서 코어수가 증가할수록 CPU 성능이 향상됩니다.

- 레지스터에 대해 설명해주세요 (작성자 : 이영은)
    - 레지스터는 CPU안에 있는 매우 빠른 임시기억 장치입니다. CPU와 직접 연결되어 있어서 연산속도가 수십배에서 수백배까지 빠릅니다. CPU는 자체적으로 데이터를 저장할 방법이 없기에 레지스터를 거쳐 데이터를 전달합니다.
    

## 메모리 계층

- 메모리 계층에 대해 설명해주세요
  - 메모리 계층은 메모리 관련 주요 특성인 용량, 접근 속도, 비용 간의 절충 관계를 파악해 필요에 따라 채택할 수 있게 나타낸 구조입니다. 위에서부터 레지스터, 캐시, 메모리, 하드 디스크입니다.
 
- ROM에 대해 설명해주세요
  - ROM은 Read Only Memory의 약자로, 고정 기억 장치입니다. 컴퓨터에 지시사항을 영구히 저장하는 비휘발성 메모리이며 전원 종료시 기억된 내용을 유지합니다.
 
- 주기억장치와 보조기억장치의 차이점에 대해 설명해주세요.
  - 주기억장치는 CPU의 직접적인 접근이 가능하지만 보조기억장치는 불가능합니다.
  - 주기억장치는 CPU의 연산에 직접적으로 참여하지만 보조기억장치는 데이터의 저장만 가능합니다.
  - 주기억장치가 보조기억장치보다 접근 속도가 빠릅니다.
  - 보조기억장치의 용량이 주기억장치보다 높습니다.

  - RAM(Random Access Memory) 에 대해 설명해주세요 (작성자 : 이영은)
    - RAM은 읽고 쓰기가 가능하며, 응용프로그램, 운영체제 등을 불러와 CPU가 작업할 수 있도록 하는 기억장치입니다.
    - 데이터를 읽는 속도와 기록하는 속도가 같고 프로그램을 로딩하거나 데이터를 임시 저장하거나 하는 곳에 사용됩니다.
    - 전원이 끊어지면 데이터가 전부 지워지기 때문에 휘발성 메모리 라고 합니다. 따라서, 실행하고 있는 파일은 항상 보조기억장치에 저장을 해줘야 합니다.


- 메모리 구조에 대해서 설명하시오
  - 메모리 공간은 크게 코드, 데이터,스택, 힙 영역으로 나뉩니다.
    코드 영역은 실행할 프로그램의 코드가 저장되는 영역이고 0과 1인 기계어 형태로 저장됩니다.
    실행 파일을 구성하는 명령어들이 올라가는 메모리 영역으로 함수, 제어문, 상수 등리 여기에 지정되고 CPU는 코드 영역에 저장된 명령어들을 하나씩 가져가서 실행합니다.
  - 데이터 영역은 전역변수와 정적 변수가 할당되는 영역입니다. 메인 함수 전에 선언되어 프로그램의 시작과 동시에 할당되고 프로그램이 종료돼야 메모리가 소멸됩니다.
  - 힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됩니다. 응용 프로그램이 종료될 때까지 메모리가 유지되기 때문에 사용하고 난 후 반드시 메모리 해제를 해줘야 합니다.
    java에서는 가비지 컬렉터가 자동으로 해제합니다. 
    영역 중 유일하게 런타임시 크기가 결정되며 참조형 데이터 타입을 갖는 객체, 배열 등이 저장되는 공간입니다.
    메모리의 낮은 주소부터 할당되는 선입선출 구조입니다.
    단 힙영역에 있는 오브젝트들을 가리키는 레퍼런스 변수는 스택에 적재합니다.
  - 스택 영역은 프로그램이 자동으로 사용하는 임시 메모리 영역입니다.
    함수 호출 시 생성되는 지역변수와 매개 변수가 저장되는 영역이고, 함수 호출이 완료되면 저장된 메모리도 해제됩니다.
    메모리의 높은 주소부터 할당되는 후입선출 구조입니다.
  - 힙 영역과 스택 영역은 사실 같은 공간을 공유합니다. Heap이 메모리 위쪽 주소부터 할당되면 Stack은 아래쪽부터 할당되는 식입니다.
    그래서 각 영역이 상대 공간을 침범하는 일이 방생할 수 있는데, 이를 각각 Heap Overflow, Stack Overflow라고 칭합니다.
    따라서 Stack 영역이 클수록 Heap영역이 작아지고, Heap 영역이 크면 Stack영역이 작아집니다.
  

- 메모리의 힙 영역과 스택 영역의 차이에 대해 설명해주세요.
  - 두 영역은 같은 물리 메모리 공간을 공유하는데, 스택은 높은 주소에서 낮은 주소로, 힙은 낮은 주소에서 높은 주소로 채워지기 때문에 서로의 영역을 누가 침범하느냐에 따라 heap overflow, stack overflow가 발생할 수 있습니다.


- 메모리의 힙 영역을 너무 크게 잡으면 어떤 일이 생길까요?
  - 힙 영역은 스택 영역과 다르게 직접 생성된 변수를 제거를 통해 메모리 관리가 필요합니다.
    만약 메모리의 힙 영역이 너무 크다면, 넓은 힙 영역에 존재하는 동적 변수에 대해 참조 여부를 확인해야 하기 때문에 Garbage Collect의 수행시간이 너무 길어지게 됩니다.
    따라서 Java의 JVM에서도 처음부터 힙 영역을 크게 잡지 않고, Heap 영역이 꽉 찼을 때 GC 진행 후 Heap 영역을 확장하게 됩니다.


## 프로세스와 스레드

- 프로세스와 쓰레드의 차이에 대해 설명해주세요 (작성자 : 이영은)
    - 프로세스는 실행 중인 프로그램을 말하며, 완벽히 독립적이기 때문에 메모리 영역을 다른 프로세스와 공유하지 않습니다. 프로세스는 최소 1개의 쓰레드를 가지고 있습니다.
    - 쓰레드는 프로세스 내에서 Stack만 따로 할당 받고, 그 이외의 메모리 영역을 공유하기 때문에 다른 쓰레드의 실행 결과를 즉시 확인할 수 있습니다. 쓰레드는 프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행됩니다.

- Context Switching이 무엇인지 설명해 주세요. (작성자 : 이영은)
    - 멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 상태 또는 레지스터 값을 저장하고 CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값을 교체하는 작업을 말합니다.

- 프로세스와 프로그램의 차이에 대해 설명해주세요
  - 프로그램은 어떤 작업을 하기 위해 실행할 수 있는 파일이고 프로세스는 실행되어 작업중인 프로그램입니다. 프로그램은 파일이 저장 장치에 있지만 메모리에 올라가 있지 않은 정적인 상태이며 쉽게 말해 코드 덩어리라고 할 수 있습니다. 반면 프로세스는 메모리에 적재되고 CPU 자원을 할당받아 프로그램이 실행되고 있는 상태이며 해당 코드 덩어리를 실행한 것입니다.
 

- Core란 무엇인가요?
  - Cpu 기본 계산 단위를 의미합니다.


- 프로세스는 운영체제에 어떻게 저장되나요?
  - 특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조인 PCB를 통해 저장됩니다.
  - PID, Process Status, PC(프로세스 실행을 위한 다음 명령의 주소를 표시), CPU 레지스터, CPU 스케줄링 정보 등으로 구성되어 있습니다.


- 스택은 스레드마다 독립적으로 할당하는 이유가 무엇인가요?
  - 스레드는 독립적인 동작을 수행하기 위해 존재합니다. 따라서 독립적으로 함수 호출이 가능해야하기 떄문에 
    함수의 인자, 반환 주소, 매개변수 등을 저장하는 스택 메모리 영역은 독립적으로 할당 받아야합니다.

- 멀티 프로세스 대신 멀티 쓰레드를 사용하는 이유는 무엇인가요?
  - 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행할 경우, 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있습니다.
  - 또 프로세스간의 통신보다 쓰레드간의 통신비용이 더 적게 들고 전환 속도가 빠릅니다. 
  
    
## CPU 스케줄링 알고리즘
- 비선점형 스케줄링에 대해 설명해주세요.(작성자 : 이영은)
    - 비선점형 스케줄링은 프로세스가 스스로 CPU 소유권을 포기하는 방식이며, 강제로 프로세스를 중지하지 않는 방식입니다. 강제성이 없기에 프로세스간 교류가 적어지므로 컨텍스트 스위칭으로 인한 부하가 적습니다. 비선점형 스케줄링에는 선입선처리 스케줄링, 최단 작업 우선 스케줄링, 우선순위 스케줄링이  있습니다.
    - 선입선처리(FCFS) 스케줄링은 가장 단순한 스케줄링 알고리즘이지만 짧은 프로세스가 매우 긴 프로세스를 기다리게 할 수 있습니다.
    - 최단 작업 우선(SJF) 스케줄링은 최적이며 평균 대기 시간이 가장 짧습니다. 그러ㄴ나 다음 CPU 버스트의 길이를 예측하기 어려우므로 SJF 스케줄링을 구현하는 것은 어렵습니다.
    - 우선순위 스케줄링은 각 프로세스에 우선순위를 배정하고 CPU는 우선순위가 가장 높은 프로세스에 할당됩니다. 우선순위가 동일한 프로세스는 FCFS순서 또는 RR  스케줄링을 사용하여 스케줄 할 수 있습니다
- 선점형 스케줄링에 대해 설명해주세요.
  - 선점형 스케줄링은 CPU가 프로세스를 실행중이어도 우선순위가 더 높은 프로세스가 CPU를 강제로 빼앗아 실행할 수 있는 스케줄링 기법입니다.
  - 라운드 로빈(RR)은 각 프로세스에 동일한 시간 할당량(Time quantum)을 부여하고, 시간이 경과하면 다음 프로세스로 넘어가는 스케줄링입니다. 시분할 기법이라고도 부릅니다.
  - 최단 작업 우선(SRT)은 실행시간이 더 짧은 프로세스가 도착하면 CPU를 선점하는 스케줄링입니다.
  - 우선순위 스케줄링은 우선순위가 더 높은 프로세스가 도착하면 CPU를 선점하는 스케줄링입니다. 
- CPU 스케줄링에 대해 설명해주세요
  - CPU 스케줄링이란 언제 어떤 프로세스에 CPU를 할당할지 결졍하는 작업입니다. CPU 이용률을 극대화하기 위해서는 멀티 프로그래밍이 필요하며 이때 CPU 스케줄링이 필요합니다.

- CPU의 성능 척도에는 무엇이 있는지 설명해주세요.
  - 시스템 입장에서의 성능은 CPU를 쉬지 않고 최대한 많이 돌리는 것이 중요하기때문에
    전체시간 중 CPU가 일한 시간의 비율인 CPU 이용률과 단위 시간당 프로세스를 몇개 완료시켰는가가 중요한 단위 시간 당 처리량이 있습니다.
   사용자 입장에서의 성능 척도는 자신이 요청한 작업이 빨리 처리되는 것이 중요하기 때문에
   프로세스가 Ready queue에서 기다린 시간인 대기 시간과 프로세스가 최초로 CPU를 얻기까지 걸린 시간인 응답 시간, 프로세스가 처음 도착해서 끝나기까지 걸린 시간 소요시간, 반환시간이 있습니다.


## 인터럽트(Interrupt)
- 내부 / 외부 인터럽트는 어떤 상황들이 있는지 말해주세요. (작성자 : 이영은)
    - **내부 인터럽트**는 하드웨어 고장, 실행할 수 없는 명령어, 명령어 실행 오류, 사용 권한 위배 등이 있습니다. **하드웨어 고장**은 컴퓨터 고장 또는 비트 오류가 있으며, **명령어 실행 오류**는 나누기 0과 같은 경우, **사용 권한 위배**는 말 그대로 사용자가 OS만 접근 가능한 곳에 엑세스한 경우 입니다.
    - **외부 인터럽트**는 보통 외부 입출력장치에 의해 발생하는데, 대표적으로 전원 버튼 누르기인 **컴퓨터 종료**, 타이머가 일정 시간 간격으로 인터럽트를 요청하는 **타이머 인터럽트**, 입출력 장치가 입출력 완료를 알리기 위해 인터럽트를 요청하는 **입출력 인터럽트**가 있습니다.

- execption(예외상황)에 대해 설명해주세요
  - 프로그램이 허용되지 않은 연산을 수행하려고 할 때, 자동적으로 발생하는 것입니다. 운영체제는 예외 상황이 발생했을 때, CPU의 제어권을 획득해 이 상황에 대한 조치를 합니다.

- 인터럽트 발생시 처리 과정을 설명해주세요.
  - 인터럽트 발생시 CPU는 현재 진행중인 작업을 중단하고 다음 명령의 주소를 스택이나 메모리에 저장합니다.<br>
  운영체제는 인터럽트 유형별로 적절한 인터럽트 핸들러나 인터럽트 서비스 루틴을 호출하고 CPU는 이를 처리합니다. 이를 문맥교환이라 합니다. <br>
  인터럽트의 처리가 완료되면 저장했던 명령어의 주소에 따라 진행중이던 작업을 재개합니다. <br>

- 인터럽트에 대해 설명해주세요.
  - 인터럽트는 프로그램을 실행하고 있는 도중에 입출력 요청 혹은 예외 상황을 처리해야 하면 실행하던 프로그램을 멈추고 CPU가 해당 작업을 처리하도록 하는 것을 의미합니다.


## 시스템 콜(System Call)

- 운영체제는 왜 이중 동작 모드로 구동 되는지 설명해주세요. (작성자 : 이영은)
    - 바로 시스템을 보호하기 위해서 입니다. 예를 들어 사용자가 권한 없이 시스템 내부의 데이터를 만질 수 있다고 가정해보겠습니다. 이럴 경우 쉽게 내부 데이터 접근이 가능하여 의도치 않게 또는 악의적으로 시스템을 해칠 수가 있습니다. 이런 경우를 대비해 시스템을 보호하기 위해서 이중 동작 모드로 구동이 됩니다. 이렇게 구동되어 유저 애플리케이션이 함부로 시스템 자원에 접근할 수 없게 합니다.

- 시스템 콜의 유형에 대해 설명해주세요.
  - 시스템 콜의 유형으로는 프로세스 제어, 파일 조작, 디바이스 조작, 정보 유지, 통신, 보호 등이 있습니다.

- 시스템 콜에 대해 설명해주세요
  - 시스템 콜이란 운영체제가 제공하는 서비스를 사용하기 위한 프로그래밍 인터페이스입니다. 사용자는 접근할 수 있는 메모리 영역이 제한되어 있고, 하드웨어에 직접적으로 접근할 수 없기 떄문에 시스템 콜을 통해 상호작용합니다.

## PCB와 Context Switching
- 프로세스 제어 블록(Process Control Block, PCB) 에 대해 설명해주세요. (작성자 : 이영은)
    - 특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조입니다. 운영체제는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB 를 생성합니다. 프로세스는 CPU 를 할당받아 작업을 처리하다가도 프로세스 전환이 발생하면 진행하던 작업을 저장하고 CPU 를 반환해야 하는데, 이때 작업의 진행 상황을 모두 PCB 에 저장하게 됩니다. 그리고 다시 CPU 를 할당받게 되면 PCB 에 저장되어있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행합니다.

- context switching에 대해 설명해주세요
  - CPU가 현재 작업 중인 프로세스에서 다른 프로세스로 넘어갈 때 지금까지의 프로세스 상태를 저장하고, 새 프로세스의 저장된 상태를 다시 적재하는 작업입니다. 주로 한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생합니다.

- Context Switiching의 문제점과 개선방안에 대해 설명해주세요.
  - 문맥교환은 그 과정에서 오버헤드와 문맥교환 비용이 발생시켜 성능이 저하될 수 있고 캐시 메모리를 사용하지 않아 캐시 메모리의 장점이 사라집니다. <br>
  - 따라서 다중코어나 높은 수준의 스케줄링 알고리즘 등을 사용하면 문맥교환 횟수를 줄여 성능 저하를 줄일 수 있습니다. <br>

- PCB는 어떻게 관리되나요? 
  - Linked List 방식으로 관리됩니다. PCB List Head에 PCB들이 생성될 때마다 붙게 됩니다. 
    주소값으로 연결이 이루어져 있는 연결리스트이기 때문에 삽입 삭제가 용이합니다.
    즉, 프로세스가 생성되면 해당 PCB가 생성되고 프로세스 완료 시 제거됩니다.

- Context Switching이 필요한 이유가 무엇인가요?
  - 만약 컴퓨터가 매번 하나의 Task만 처리할 수 있다면
    다음 Task를 처리하기 위해서 현재 Task가 끝날 때까지 기다려야하기 때문에
    반응 속도가 매우 느리고 사용하기 불편하므로 Context Switching이 필요합니다.


## 주소 공간과 가상 메모리(Address Space, Virtual Memory)
- 가상 메모리를 통해서 우리는 어떤 장점을 얻을 수 있는지 설명해주세요 (작성자 : 이영은)
    - 프로그램의 일부분만 메모리에 올릴 수 있게 되었고 이를 통해 물리 메모리 크기에 제약을 받지 않게 되었습니다. 고로 더 많은 프로그램을 동시에 실행할 수 있게 되었다. 또한 swap에 필요한 입출력이 줄었기 때문에 프로그램들이 빠르게 실행된다는 장점을 가지고 있습니다.

- 주소 공간의 4 영역에 대해 설명해주세요
  - code, data, heap, stack 영역입니다. code 영역은 프로그램이 실행될 수 있도록 CPU가 해석 가능한 기계어 코드가 저장되어 있는 공간으로 수정되면 안 되므로 ReadOnly 상태로 저장됩니다. data 영역은 전역변수, static 변수의 할당의 위해 존재하는 공간입니다. 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸됩니다. heap 영역은 프로그래머의 동적 할당을 위해 존재하는 공간으로 런타임에 크기가 결정되는 영역입니다. stack은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 공간입니다. Stack 영역의 값은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸됩니다. 

- 가상 메모리가 무엇인지 설명해주세요.
  - 가상메모리는 '멀티 프로그래밍' 기법에서 나온 개념으로 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법입니다. 가상메모리가 없다면 실행되는 코드의 전부를 적재해야 하므로 메모리 용량보다 큰 프로그램을 실행할 수 없습니다.
    가상메모리를 사용하면 동시에 많은 프로그램을 실행할 수 있고, 응답시간을 유지하면서 CPU 이용률과 처리율을 높일 수 있습니다.
    단점으로는 물리메모리의 구동보다는 속도가 느리다는 단점이 있습니다.

## 주소 변환(Address Translation)

## 세그먼테이션(Segmentation)

## 페이징(Paging)

## 가상메모리와 요구 페이징, 페이지 교체

## TLB(Translation Lookaside Buffers)

## TLB 심화

## Paging : Smaller Table

## 동기화(스핀락, 세마포어, 뮤텍스)

## 교착상태(DeadLock)

## 멀티프로세스, 스레드와 멀티스레딩


---

📚 출처

- https://dev-coco.tistory.com/162
  
[메모리 계층]
- https://velog.io/@shindoyeon/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0 
- https://hoons-dev.tistory.com/95

[프로세스&스레드]
- https://suhyunsim.github.io/2023-03-14/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EB%A9%B4%EC%A0%91%EC%A7%88%EB%AC%B8
- https://velog.io/@hyeonahhh/%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-VS-%EC%8A%A4%EB%A0%88%EB%93%9C


[CPU 스케줄링 알고리즘]
- https://dkswnkk.tistory.com/405

[인터럽트]
- https://maivve.tistory.com/273


[시스템 콜]
- https://c4u-rdav.tistory.com/85

[PCB와 ContextSwitching]
- https://velog.io/@bsm4045/운영체제-면접질문

[주소공간과 가상메모리]
- https://imbf.github.io/interview/2020/11/26/NAVER-Interview-Preparation-1.html
