# 세그먼테이션(Segmentation)

## 동적재배치의 문제점

주소 변환 기법으로 동적 재배치 기법이 사용되고, 이는 몇 가지 문제점이 있다. <br>
그 중 가장 주요한 문제점은 단편화(Fregmentation) 문제이다. 

### Fregmentation 

- **외부 단편화**
  
  ![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/434624ee-240d-4f3b-92fc-b48616517384)

  전체 남는 메모리의 크기는 프로그램의 크기보다 크지만 메모리 조각들은 프로그램의 크기보다 작은 경우

- **내부 단편화**
  
  ![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/858d0142-da72-46fe-92cc-8fdd99ede4a5)

  남는 메모리의 크기가 프로그램의 크기보다 커서 적재는 가능하지만, 남는 메모리 공간이 너무 커서 비효율적인 경우

  >**동적재배치 관점에서 내부 단편화**
  >![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/855c821c-73c2-43ec-92cd-228fa3d1c2de)
  >주소 공간에서 물리 메모리로 재배치할 때 Heap과 Stack 사이의 빈 공간도 그대로 매핑되므로 <br>
  >물리 메모리상에서도 낭비되는 메모리 공간이 발생한다. 



## 내부 단편화의 해결법 

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/c3987519-9c7e-4662-8e09-def75d079734)

대표적인 내부 단편화의 해결법은 세그먼테이션을 사용하는 것이다. <br>
세그멘테이션은 프로세스를 논리적 내용을 기반으로 나눠서 메모리에 독립적으로 각각 배치하는 것을 의미한다. <br>
이때 프로세스는 **3개의 세그먼트, Code영역, Stack영역, Heap영역**으로 구성된다. <br>

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/c3ff4d72-1998-4510-b150-92f4d4fc9c4f)


세그먼테이션은 세그먼트 테이블을 갖고, 세그먼트 테이블의 각 항목은 **Segment Base와 Segment Limit**을 갖는다. <br>
Base는 물리 주소의 시작점을 나타내고, Limit은 세그먼트의 길이를 나타낸다. (세그먼트의 길이는 일정하지 않기 때문) <br>
만약 Limit를 넘는다면 인터럽트가 발생해 프로세스는 강제 종료될 것이다. <br>


**1) 가상 주소 해석** <br>
프로세스가 실행되면 가상 주소를 가져오고, 이 가상 주소는 세그먼트 번호와 오프셋(offset)으로 구성돼있다. <br>
세그먼트 번호는 세그먼트 테이블 인덱싱을 위한 인덱스로 사용되고 오프셋은 해당 세그먼트에서 데이터의 실제 위치를 나타낸다. <br>

**2) 세그먼트 테이블 접근** <br>
세그먼트 번호를 이용해 세그먼트 테이블에 접근한다. 세그먼트 테이블은 베이스와 리밋을 포함하고 있다. <br>

**3) Base와 Limit 검사** <br>
세그먼트의 시작 물리 주소인 Base와 세그먼트의 길이인 Limit을 테이블로부터 가져온다. <br>

**4) 주소변환** <br>
Offset이 Limit의 범위 내인지 확인 후 Base와 Offset값을 더해 물리주소로 변환한다. <br>

>**ex)** <br>
>1. 논리주소 <2, 100> -> base[2] + 100 = 4400(물리주소)<br>
>2. 논리주소 <1, 500> -> base[1] + 500 = limit이 400이므로 범위를 벗어나 인터럽트가 발생한다.<br>

## 여전한 단편화 문제 

세그먼테이션은 내부 단편화 문제를 해결하기 위해 고안된 방법이라 여전히 외부 단편화 문제를 가진다. <br>
각 세그먼트의 크기가 달라 물리 메모리에 여유 공간이 남기 때문이다. <br>
이를 해결하기 위해 OS는 압축(Compaction)이라는 세그먼트 재배치 기법을 사용하지만 이는 비용 문제가 발생한다. <br>
>**압축(Compaction)**<br>
>주기억장치에 분산되어 있는 단편화된 공간들을 통합하여 하나의 공간으로 만들어 재배치한다.<br>

**페이징**은 고정된 크기의 세그먼트로 외부 단편화를 제거하여 여유 공간을 관리할 수 있다. <br>
하지만 페이징 또한 내부 단편화의 문제가 있으며, 최근에는 세그먼테이션과 페이션을 적절히 혼합하여 사용해 서로의 문제점을 보완해준다. 



#### 출처
https://variety82p.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-OS%EB%8B%A8%ED%8E%B8%ED%99%94%EC%99%80-%EB%8B%A8%ED%8E%B8%ED%99%94-%ED%95%B4%EA%B2%B0%EB%B2%95
https://4legs-study.tistory.com/50
https://code-lab1.tistory.com/57




