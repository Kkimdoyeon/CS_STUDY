# 세그먼테이션(Segmentation)

## 동적재배치의 문제점

주소 변환 기법으로 동적 재배치 기법이 사용되고, 이는 몇 가지 문제점이 있다. <br>
그 중 가장 주요한 문제점은 단편화(Fregmentation) 문제이다. 

### Fregmentation 

- **외부 단편화**
  
  ![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/434624ee-240d-4f3b-92fc-b48616517384)

  전체 남는 메모리의 크기는 프로그램의 크기보다 크지만 메모리 조각들은 프로그램의 크기보다 작은 경우

- **내부 단편화**
  
  ![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/858d0142-da72-46fe-92cc-8fdd99ede4a5)

  남는 메모리의 크기가 프로그램의 크기보다 커서 적재는 가능하지만, 남는 메모리 공간이 너무 커서 비효율적인 경우

  >**동적재배치 관점에서 내부 단편화**
  >![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/855c821c-73c2-43ec-92cd-228fa3d1c2de)
  >주소 공간에서 물리 메모리로 재배치할 때 Heap과 Stack 사이의 빈 공간도 그대로 매핑되므로 <br>
  >물리 메모리상에서도 낭비되는 메모리 공간이 발생한다. 



## 내부 단편화의 해결법 

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/c3987519-9c7e-4662-8e09-def75d079734)

대표적인 내부 단편화의 해결법은 세그먼테이션을 사용하는 것이다. <br>
세그멘테이션은 프로세스를 논리적 내용을 기반으로 나눠서 메모리에 독립적으로 각각 배치하는 것을 의미한다. <br>
이때 프로세스는 **3개의 세그먼트, Code영역, Stack영역, Heap영역**으로 구성된다. <br>

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/c3ff4d72-1998-4510-b150-92f4d4fc9c4f)


세그먼테이션은 세그먼트 테이블을 갖고, 세그먼트 테이블의 각 항목은 **Segment Base와 Segment Limit**을 갖는다. <br>
Base는 물리 주소의 시작점을 나타내고, Limit은 세그먼트의 길이를 나타낸다. (세그먼트의 길이는 일정하지 않기 때문) <br>
만약 Limit를 넘는다면 인터럽트가 발생해 프로세스는 강제 종료될 것이다. <br>


**1) 가상 주소 해석** <br>
프로세스가 실행되면 가상 주소를 가져오고, 이 가상 주소는 세그먼트 번호와 오프셋(offset)으로 구성돼있다. <br>
세그먼트 번호는 세그먼트 테이블 인덱싱을 위한 인덱스로 사용되고 오프셋은 해당 세그먼트에서 데이터의 실제 위치를 나타낸다. <br>

**2) 세그먼트 테이블 접근** <br>
세그먼트 번호를 이용해 세그먼트 테이블에 접근한다. 세그먼트 테이블은 베이스와 리밋을 포함하고 있다. <br>

**3) Base와 Limit 검사** <br>
세그먼트의 시작 물리 주소인 Base와 세그먼트의 길이인 Limit을 테이블로부터 가져온다. <br>

**4) 주소변환** <br>
Limit의 범위 내인지 확인 후 Base와 Offset값을 더해 물리주소로 변환한다. <br>

#### 출처
https://variety82p.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-OS%EB%8B%A8%ED%8E%B8%ED%99%94%EC%99%80-%EB%8B%A8%ED%8E%B8%ED%99%94-%ED%95%B4%EA%B2%B0%EB%B2%95




