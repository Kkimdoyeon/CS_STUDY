# Race Condition(경쟁 상태)
여러 개의 프로세스가 공유 자원에 동시 접근할 때 실행 순서에 따라 결과값이 달라질 수 있는 현상

이는 컴퓨터 입장에서 아주 큰 문제

똑같은 코드 100번 돌려도 값은 같아야 함
하지만 경쟁 상태가 발생하면 결과가 달라질 수 있음 

이러한 문제를 방지하기 위해 공유 메모리를 쓰는 프로세스끼리 **동기화** 를 해줘야 함


# 결쟁 상태의 해결 방안:  쓰레드의 순차적 실행을 보장해주는 동기화 

- 임계구역(Critical Section)
  - 경쟁상태가 발생할 수 있는 코드의 조각들
  - 임계구역 문제 : 임계구역에서 경쟁 상태가 발생한 것
  

- 임계구역의 세가지 요구조건 : 아래의 세 가지 요구조건을 만족시켜야 유효한 알고리즘임
  - Mutual Exclusion(상호 배제) -> 하나의 자원에는 하나의 프로세스만 접근할 수 있어야 함
  - Progress(진행) -> 임계구역이 비어있으면 자원을 사용할 수 있어야 함(deadlock free)
  - Bounded Waiting(한계 대기) -> 존버하면 언젠가는 임계구역에 진입할 수 있어야 함(starvation free)

# 동기화를 제공하는 방법

## Lock
  - Lock이라는 의미 그대로 내가 자원을 사용하는 동안 다른 프로세스가 접근하지 못하도록 잠그는 방법
```
while (lock == true) {
	lock = true;
    
    // 공유 자원에 접근하는 코드
    
    // 기저사례
    if (condition == true) {
    	lock = false;
    }
}
```

위의 코드를 살펴보면 lock이 true인 상태에 while문이 무한 반복상태에 들어감 
그리고 lock이 false가 된 순간 다른 프로세스가 lock을 true로 만들고 임계영역에 진입하게 됨

하지만, 이 방식에는 문제가 있음
lock을 true로 바꾸는 행위와 while (lock == true)의 행위가 동시에 일어나지 않는다는 것
자주있는 일은 아니겠지만, 운이 나쁘다면 저 찰라의 순간에 동시성이 붕괴되는 이슈가 발생할 수 있음


## 세마포어
두가지 연산으로 이루어져 있으며, 임계영역의 사용이 끝났으면 사용이 끝난 프로세스가 대기중인 프로세스에게 사용이 끝났다는 사실을 알려주는 방식임.
이와 같이 세마포어는 무한반복을 사용하지 않으므로 cpu 리소스를 줄여줄 수 있음.

세마포어는 정수 값을 가지는 변수로 볼수 있는데, 
이 정수 값은 접근할 수 있는 최대 허용치 만큼 동시에 사용자가 접근할 수 있음.
세마 포어에는 두가지 연산을 가지고 있음.



semWait : 세마포어 값을 감소시킴. 만약 세마포어가 음수가 되면 프로세스는 블록 상태가 됨.

semSignal : 세마포어 값을 증가시킴. 만약 값이 0이거나 음수일 경우엔, semwait 연산으로 블록된 프로세스를 깨움.

다만 이러한 세마포어 역시 문제점이 존재. 바로 개발자의 실수임. 정확히 쓰면 문제가 발생하지 않지만, 멀티 스레드나 멀티 프로세싱 환경에서는 이러한 실수가 잘 발견되지 않기 때문에 개발자의 실수를 줄여줄 다른 방법이 필요하게 됨.



## 뮤텍스
뮤텍스 역시 세마포어와 마찬가지로 병행 처리를 위한 동기화 기법임. 
다만 세마포어와는 달리 오직 1개의 프로세스 혹은 스레드만 접근할 수 있음.


# 모니터

그래서 나온 것이 모니터 방법임.
모니터란 공유 자원을 내부적으로 가지고 있고 외부에 공개하지 않음.
이는 마치 클래스의 private 접근자 변수와 유사함. 
그리고 public 메서드 (getter와 같은)를 통해서만 공유 자원에 접근할 수 있음. 
모니터는 뮤텍스와 같이 한번에 한번의 프로세스만 입장할 수 있다는 특징이 있음.


출처: https://ooeunz.tistory.com/94



