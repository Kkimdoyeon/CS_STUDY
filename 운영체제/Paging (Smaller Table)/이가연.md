# 페이징 개선 

이전 챕터에서 페이징의 주요 단점으로 물리 메모리에 두 번 접근하며 생기는 오버헤드와, 이에 대한 해결책인 TLB에 대해 소개하였다. <br>
그런데 TLB가 관리 가능한 범위보다 **더 많은 페이지를 사용**하는 경우에는 어떻게 해야할까? <br>

페이지가 많아지면 가장 큰 단점은 **페이징 테이블의 크기가 너무 커진다**는 것이다. <br>
페이징 테이블 자체가 차지하는 메모리도 거대해지고 테이블에서 정보를 찾는 시간도 증가한다. <br>
페이지 테이블의 크기는 (가상 주소 공간의 크기 / page의 크기 ) x page table entry의 크기로 구해진다. <br>
그렇다면 page의 크기를 늘리면 테이블의 크기가 줄어들지 않을까? <br>
줄어드는 것은 맞지만, 근본적인 해결책은 아니다. <br>
페이지의 크기가 너무 커지면 이전에는 무시 가능한 정도였던 내부 단편화의 영향력이 너무 커지기 때문이다. <br>

## Hybrid Approach ( Paging + Segmentation )

가상 메모리에서 메모리 관리를 위해 주소 변환 기법 두 가지 페이징과 세그먼테이션을 소개했다. 이들은 각각 장단점을 지닌다. <br>
Hybrid Approach는 두 기법을 적절히 섞어 서로의 장단점을 보완하고 최대한 활용하는 기법이다. <br>
우선 가상 메모리는 세그먼트 단위로 나누고 각 세그먼트 (Code, Heap, Stack) 별로 총 3개의 페이징 테이블을 두는 것이다. 

<img src="https://github.com/dlrkdus/CS_STUDY/assets/99721126/ea7af9b7-1bb5-4ef9-aea9-0fc6de6f3da8" width="70%">

이때 기존에 물리 메모리의 시작 주소를 나타내던 base 레지스터와 크기를 나타내던 bound 레지스터는 <br>
각각 **세그먼트의 페이지 테이블 시작 주소**와 **페이지 테이블의 끝**이 된다. <br>

<img src="https://github.com/dlrkdus/CS_STUDY/assets/99721126/1c5129ad-677c-4042-9ac5-7d114b9464df" width="70%">

<img src="https://github.com/dlrkdus/CS_STUDY/assets/99721126/ab1958c0-322f-4f19-a282-704241c3e0c8" width="50%">


이 시스템에서 모든 프로세스는 3개의 페이징 테이블을 갖게 된다. <br>
문맥교환시 base/bound 레지스터 쌍은 새로 실행되는 프로세스의 페이지 테이블 관련 정보로 변경된다. <br>
TLB 미스가 발생하면, 하드웨어는 페이지 테이블에 접근해야 하므로 세그먼트 비트를 이용해 base/bound 쌍을 결정한다. <br>
그 뒤 물리주소를 사용해 PTE의 주소를 도출한다. <br>

이 기법의 핵심은 **세그먼트마다 bound 레지스터가 존재**한다는 점이다. <br>
이 bound 레지스터는 페이지 테이블의 끝 주소를 가지기 때문에 사용하지 않는 page table의 공간을 유지할 필요가 없어지므로 <br>
기존의 선형 테이블에 비해 메모리 낭비를 줄일 수 있다. <br>
스택과 힙 사이에서 낭비되던 공간(페이지)들은 페이지 테이블 상에서 더이상 공간을 차지하지 않는다. <br>

### 단점

- Segmentation은 Heap의 성격과 맞지 않다. 힙과 스택 사이의 공간은 아낄 수 있지만 힙이 큰 공간을 차지하고 잘 사용되지 않는다면 여전히 힙의 영역만큼은 낭비가 된다. <br>
- 외부 단편화 문제가 여전히 발생한다.

## Mutil-Level Page Tables

세그멘테이션을 사용하니 여전히 세그멘테이션의 단점을 따라가게 된다. <br>
따라서 세그멘테이션을 사용하지 않고 페이지 테이블의 크기를 줄일 방법을 생각해보자. <br>
이 기법은 테이블에서 사용하지 않는 공간을 제거하는 방법이다. 

- 트리와 같은 형태이다. 
- 페이지 테이블을 페이지 크기 단위로 나눈다.
- 유효한 엔트리가 없는 페이지 테이블은 할당하지 않는다.
- 테이블의 할당 여부와 위치를 관리하기 위해 **Page Directory**가 존재한다.

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/a27e8795-2551-4855-87c3-e28c57438fb9)

Page Directory에서 valid bit로 유효성 여부를 관리하는 것을 볼 수 있다. <br>
따라서 유효하지 않은 테이블은 할당하지 않는다. <br>
일부라도 유효한 엔트리가 있는 테이블(201,204)는 Page Directory에서 v로 관리되지만, <br>
유효한 엔트리가 하나도 없는 테이블은 i로 관리된다. <br>

### 장점

- 페이지 테이블의 크기를 효과적으로 줄일 수 있다.
- 페이지 테이블을 페이지 단위로 나눔으로써 메모리 관리가 용이하다.

### 단점

- TLB 미스시 메모리 접근 횟수가 늘어나 메모리 접근 시간이 증가한다.  단, 대부분의 메모리는 TLB 히트이다.
- 구현이 복잡하다.

단점에도 불구하고 Mutil-level Table은 굉장히 효율적이고 실제 OS에서 사용된다. 







#### 출처
https://koolreview.tistory.com/100 <br>
https://koolreview.tistory.com/101


