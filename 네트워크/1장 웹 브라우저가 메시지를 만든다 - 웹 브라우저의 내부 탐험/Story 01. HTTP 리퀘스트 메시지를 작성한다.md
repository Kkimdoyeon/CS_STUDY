
# 브라우저는 먼저 URL을 해독한다

브라우저가 웹 페이지를 요청하고 표시하는 과정에서 가장 첫번째 단계가 URL을 해독하고 분석하는 것이다.

## 1. URL의 구성 요소

```bash
https://www.example.com:8080/path/to/resource?query=abc#fragment
```

- **프로토콜** : `https://`
    - 웹에서 사용되는 통신규약, 주로 http(80) / https(443)
    - 브라우저는 이 프로토콜을 해독해 서버와의 통신 방식을 결정한다.
- **도메인(**호스트) : `www.example.com`
    - 브라우저는 해당 도메인으로 서버의 IP 주소를 찾기 위해 DNS(Domain Name System)을 조회한다.
    - 먼저 **로컬 DNS 캐시**에 해당 도메인이 있는지 확인하고, 없으면 **ISP**(Internet Service Provider)나 외부 DNS 서버에 요청을 보낸다.
    - 조회가 성공하면 저장하고 해당 서버와 통신할 준비를 한다.
- **포트 번호** : `8080`
    - 웹 서버가 사용하는 포트 번호로 생략 가능하다.
- **경로** : `/path/to/resource`
    - 요청할 리소스의 경로, 서버에 저장된 정적 파일 등이 해당.
    - 브라우저는 이 경로를 사용해 서버가 제공해야 할 리소스 위치를 식별한다.
- **쿼리 문자열** : `?query=abc`
    - URL에 추가적인 데이터를 포함해 서버로 보낼 때 사용
- **프래그먼트** : `#fragment`
    - 페이지 내 특정 섹션이나 위치로 이동할 때 사용

# 파일명을 생략한 경우

URL 경로에 특정 파일명을 포함하지 않고 디렉토리 경로만 명시된 경우를 의미한다. 

```bash
GET / HTTP/1.1       
Host: http://example.com/index.html
```

```bash
GET / HTTP/1.1       (파일명 생략된 루트 경로)
Host: http://example.com/
```

## 기본 파일이 있는 경우

파일명을 생략한 경우 웹 서버는 기본적으로 해당 디렉토리의 루트 파일을 반환한다. 위와 같은 경우, [`http://example.com/`](http://example.com/) 로 요청을 보내도 해당 디렉토리의 기본 페이지인 index.html을 반환한다. 

## 기본 파일이 없는 경우

서버는 기본 파일이 없는 경우 디렉토리 목록을 반환하거나 404 에러 오류 메시지를 반환할 수 있다. 

# HTTP의 기본 개념

HTTP는 서버와 클라이언트가 서로 데이터를 주고받기 위해 사용되는 `통신 규약`을 일컷는다. 

HTML, TEXT, IMAGE, JSON 등 거의 모든 형태의 데이터를 전송할 수 있다. 

가장 많이 사용되는 것은 TCP 기반이 HTTP/1.1 이다. 

## HTTP 통신 구조

![image](https://github.com/user-attachments/assets/37dc71ca-49f7-4a93-b8bd-b8f7d7d75874)


HTTP 통신은 클라이언트와 서버로 나뉘어진 구조로 되어있다. 

클라이언트가 요청하면(HTTP 메세지를 보내면) 서버가 응답(요청에 대한 결과를 만들어 응답)하는 것이다. 

왜 이렇게 클랑이언트와 서버를 분리해야 하는걸까? 이유는 **각자의 역할에 집중**할 수 있기 때문이다. 

클라이언트는 비즈니스 로직이나 데이터를 신경 쓰지 않고 UI를 구성하는데 집중하면 되고, 반대로 서버는 비즈니스 로직과 데이터만 신경 쓰면 된다. **책임을 나눠 각 책임을 독립적으로 고도화하는 것이다.** 

## HTTP의 무상태성 (Stateless)

HTTP는 대표적인 무상태 통신 규약이다. 

### 상태유지(Stateful)

![image](https://github.com/user-attachments/assets/5b357567-16ae-4498-b019-90f559e33330)


- 서버가 클라이언트 상태를 보존한다.
- 따라서 서버에 장애가 발생하면 클라이언트는 처음부터 다시 작업을 요청해야 한다. 서버가 바뀔 때마다 클라이언트의 내용을 기록해서 상태를 유지해야 하기 때문이다.
- 대표적으로 FTP, Telnet, SSH, SMTP, POP3 등이 있다.

### 무상태(Stateless)

![image](https://github.com/user-attachments/assets/6b74a00d-bc3b-453f-a16d-c7b05220ea83)


- 서버가 클라이언트의 상태를 보존하지 않는다.
- 만약 회원 로그인을 한다면 페이지를 옮겼을 때 서버는 클라이언트의 상태를 보존하지 않기 때문에 해당 클라이언트가 회원인지 알 수 없어 또 로그인 요청을 보낸다.
- 따라서 이러한 환경에서는 회원 정보를 서버가 아닌 클라이언트가 토큰 형태로 들고 있으면서 서버와 통신할 때 실어 보낸다.
- 무상태 환경은 클라이언트가 상태 정보를 갖고 있어 아무 서버나 호출해도 되기 때문에 **Scale-Out 환경에 유리**하다.
- 상태유지보다는 데이터를 많이 사용한다는 단점이 있긴 하다.

## HTTP의 비연결성

HTTP는 연결을 유지하지 않는 모델이다. 즉, 서버와 클라이언트의 Connection 연결을 지속하지 않는다.

비연결성이란 클라이언트가 서버에 요청을 하고 응답을 받으면 바로 TCP/IP 연결을 끊음으로써 서버 자원을 효율적으로 관리하고 수많은 클라이언트 요청에 대응할 수 있게 하는 특성을 말한다. 

<aside>
💡

**Stateless** VS **Connectionless**

무상태성은 클라이언트와 서버 간에 상태 정보를 들고 있지 않아 상태 정보를 HTTP에 실어 요청해야 된다는 것을 뜻하고, 비연결성은 클라이언트와 서버 간의 네트워크 연결이 단절되는 것을 말한다. 

</aside>

### 연결을 유지하는 모델

![image](https://github.com/user-attachments/assets/6b4b6f2e-f5bc-4dca-938e-3968c7b22b75)


네트워크 요청이 없더라도 서버와 클라이언트의 연결이 지속적으로 유지되는 모델이다. 실시간 통신이 가능하지만, 자원이 계속해서 사용된다. 대표적으로 WebSocket, SSE 등이 해당한다. 

### 연결을 유지하지 않는 모델

![image](https://github.com/user-attachments/assets/ab00aad6-9ae4-4101-9936-2faa190d1267)


연결을 유지하지 않는다는 것은, 서버의 자원을 효율적으로 사용할 수 있지만 동시에 **매번 TCP/IP 연결(TCP 3 way handshake)을 새로 맺어야 한다**는 것을 뜻한다. 이를 개선하기 위해 HTTP 지속 연결을 도입하고 있으며, 이는 HTTP/2, HTTP/3에서 더 많은 최적화가 이루어졌다. 

## 비연결성 모델의 한계 - 단기 커넥션

![image](https://github.com/user-attachments/assets/fba48084-3b65-434b-ba20-c8e219cd8700)


연결을 매번 끊는다는 것은 새로 연결을 맺을 때마다 TCP Handshake가 발생한다는 것을 뜻하고, 이는 매번 수많은 자원을 다운로드해야 한다는 것을 뜻한다. 이런 문제로 HTTP 초기에는 매 연결마다 1초 가량 소모되었다. 

### 비연결성 극복 - HTTP 지속 연결

![image](https://github.com/user-attachments/assets/c045ca4b-0fe7-45e4-8d9a-b1669681de48)


클라이언트는 서버와 소켓 연결을 한 다음 필요한 자원을 다운로드 받는다. 그리고 소켓 연결을 일정 시간 동안 더 유지함으로써 필요한 자원을 모두 다운받을 때까지 연결이 종료되지 않는다. 

# HTTP 리퀘스트 메시지를 만든다

![image](https://github.com/user-attachments/assets/d9ded26b-8d3d-4b88-a8ba-07a107f559b5)


HTTP 메시지는 기본적으로 **시작 라인**, **헤더**, **공백 라인**, **바디**로 구성되어 있다. 

해당 형식을 표준으로 내용물에 따라 요청/응답이 나뉜다. 

## HTTP 요청 메세지

![image](https://github.com/user-attachments/assets/cb5f9f80-635e-4e65-af95-2f5685d25f6e)


- **시작 라인** (Start Line)
    - Method : HTTP 메소드 (GET / POST / PUT / DELTE 등)
    - URL : 요청 대상 경로 표시
    - Version : HTTP 버전
- **헤더** (Header)
    - Headers : HTTP 전송에 필요한 부가 정보를 담고 있다. (메세지 크기, 압축 여부, 인증, 브라우저 정보, 서버 정보, 캐시 등)
- **공백 라인** (Empty Line)
    - 헤더와 바디를 구분하기 위한 라인, HTTP 메세지 값 구분을 위한 라인으르모 반드시 넣어야 하며, 메세지 바디가 없다면 공백만 넣으면 된다.
- **바디** (Message Body)
    - 전송 받은 데이터

# 리퀘스트 메시지를 보내면 응답이 되돌아온다

![image](https://github.com/user-attachments/assets/f9ba1bf3-dc8a-4af1-8918-bfa8003859ff)


응답 메세지와 요청 메세지의 가장 큰 차이점은 상태 코드 응답 여부다. 

- **시작 라인**
    - Version : HTTP 버전 정보
    - Status Code : 클라이언트가 보낸 요청에 대한 성공/실패 여부 숫자 코드 (404, 200 등)
    - Status Message : Status Code에 대한 글
- **헤더**
    - Headers: HTTP 전송에 필요한 부가 정보
- **공백 라인**
    - 헤더와 바디 구분 라인
- **바디**
    - 전송 받은 데이터

# HTTP 메서드 특성

- **안정성**
    - 호출해도 리소스 변경 가능성이 없다. (GET, HEAD 메소드만 가능)
- **멱등성**
    - 동일한 요청을 여러 번 보내도 한 번 보내는 것과 같다. (단, POST 메소드 제외)
    - 멱등성은 요청의 결과를 보고 판단한다.
- **캐시 가능**
    - 응답 결과를 캐시해 사용할 수 있는 속성 (GET, HEAD 메소드만 가능)
