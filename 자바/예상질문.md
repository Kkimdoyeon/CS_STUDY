
# 자바 면접 질문

## Gradle

- Gradle에 대해 설명해주세요
  - Gradle은 그루비 문법을 기반으로 한 자바 빌드 도구입니다. Ant, Maven 등의 이전 세대의 단점을 보완하고 장점을 취합하여 만든 오픈소스이며 빌드 자동화 및 다국어 개발 지원에 중점을 두었습니다. 

- Maven에 대해 설명해주세요.(작성자 : 이영은)
    - Maven은 프로젝트 관리 도구로 프로젝트의 모든 단계에서 사용하는 개발 도구이지만, 가장 많이 사용되는 프로젝트에 필요한 라이브러리를 자동으로 관리해주는 빌드 도구입니다. 필요한 라이브러리 jar 파일을 자동으로 다운 받을 수 있습니다. Java 기반 프로젝트의 사이클 관리를 위한 빌드 도구로 동시에 수행 등 다양한 기능을 합니다.

## 객체지향(상속, 다형성, 캡슐화 등)

- 캡슐화에 대해 설명해주세요
  - 캡슐화란 객체 지향 프로그래밍 특징 중 하나로, 데이터와 알고리즘이 하나로 묶는 것입니다. 서로 관련된 데이터와 알고리즘이 하나로 묶음으로써 사용하기가 매우 편리해지고 원하는 애플리케이션을 쉽게 제작이 가능합니다. 또한 객체를 캡슐로 싸서 객체 내부를 보호하고 정보 은닉을 할 수 있게 합니다.

- 객체지향 프로그래밍(OOP)의 4가지 특징에 대해 설명해주세요. (작성자 : 이영은)
    - 추상화, 상속, 다형성, 캡슐화가 있습니다.
    - 첫번째, 추상화란 어떤 대상을 구현할 때, 그 대상의 본질적인 특징을 정의하고, 이것에  기반하여 대상을 객체로 구현하는 것을 의미합니다. 자바에서 추상화를 구현할 수 있는 문법요소로는 추상클래스와 인터페이스가 있습니다.
    - 두번째, 상속은 기존의 클래스를 재활용하여 새로운 클래스를 작성하는 자바의 문법요소를 의미합니다. 상속은 클래스 간 공유될 수 있는 속성과 기능들을 상위 클래스로 추상화 시켜 상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용할 수 있도록 합니다.
    - 세번째, 다형성이란 어떤 객체의 속성이나 기능이 그 맥락에 따라 다른 역할을 수행할 수 있는 객체 지향의 특성을 의미합니다. 대표적인 예로 메서드 오버라이딩과 메소드 오버로딩이 있습니다.
    - 네번째, 캡슐화란 서로 연관 있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로 부터 보호하는 것입니다. 클래스의 캡슐화는 접근제한자를 통해 구현할 수 있습니다.
    
- 오버로딩과 오버라이딩에 대해 설명해주세요.(작성자 : 이영은)
    - 오버로딩은 하나의 클래스 내에서 같은 이름의 메소드를 생성하는 방식입니다. 이 때 매개변수의 갯수나 데이터타입이 달라야 합니다.
    - 오버라이딩은  부모클래스에서 상속 받은 자식 클래스에서 부모클래스의 메소드를 재정의하여 사용하는 방식입니다.
 
- 상속과 추상화의 차이에 대해 설명해주세요.
  - 추상화는 추상 메소드로 이루어진 인터페이스와 하위 클래스로 구현됩니다. 이때 하위 클래스는 인터페이스의 모든 메소드를 반드시 정의해야합니다.
  - 반면 상속은 하위 클래스가 상위 클래스의 메소드를 자유롭게 재정의할 수 있습니다. 따라서 상속이 추상화보다 포괄적이고 상위 개념입니다. 

## JVM 메모리 구조

- JVM 동작 방식에 대해 설명해주세요
  1. 자바 프로그램을 실행하면 JVM은 OS로부터 메모리를 할당받습니다.
  2. 자바 컴파일러가 자바 소스코드를 자바 바이트 코드로 컴파일 합니다.
  3. 클래스 로더는 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크 하여 런타임 데이터 영역에 올립니다.
  4. 런타임 데이터 영역에 로딩 된 바이트 코드는 실행 엔진을 통해 해석됩니다.
  5. 이 과정에서 실행 엔진에 의해 Garbage Collector의 작동과 Thread 동기화가 이루어집니다.
 
 - 가비지 컬렉션(Garbage Collection)에 대해 설명해주세요 (작성자 : 이영은)
    - 가비지 컬렉션은 JVM의 메모리 관리 기법 중 하나로 시스템에서 동적으로 할당됐던 메모리 영역 중에서 필요없어진 메모리 영역을 회수하여 메모리를 관리해주는 기법입니다.
    - GC의 작업을 수행하기 위해 JVM이 어플리케이션의 실행을 잠시 멈추고, GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업을 중단 후 (Stop The World 과정) 사용하지 않는 메모리를 제거(Mark and Sweep 과정)하고 작업이 재개됩니다.
     
## Java 컴파일 과정

- 자바 컴파일 과정에 대해 설명해주세요
  - 자바 컴파일러에 의해 자바 소스코드 파일을 자바 바이트코드 파일로 변환(컴파일)하고, JVM의 클래스 로더로 전달합니다. 이후 클래스 로더가 필요한 클래스들을 동적으로 로딩 및 링크하여 JVM의 메모리영역에 로드합니다. 적재된 바이트 코드들을 실행 엔진이 명령어 단위로 하나씩 기계어를 해석하여 어플리케이션을 실행합니다.

- 컴파일러와 인터프리터의 차이를 설명해주세요.(작성자 : 이영은)
    - 컴파일러는 전체 소스 코드를 한번에 기계어로 변환하고 실행파일을 생성하여 나중에 실행할 수 있습니다. 컴파일러의 예로는 C/C++/JAVA 등이 있습니다. 컴파일러의 장점은 실행속도가 빠르다는 것이고, 단점은 컴파일 과정에서 시간이 소요된다는 점입니다.
    - 인터프리터는 프로그램을 실행하는 동안에만 소스 코드를 한 줄씩 기계어로 변환하고 즉시 실행합니다. 인터프리터의 예로는 Python/Ruby/javaScript 등이 있습니다. 인터프리터의 장점은 개발과 디버깅이 빠르다는 것이고, 단점은 실행속도가 컴파일러에 비해 느리다는 것입니다.

## Java 클래스 로더

- 클래스 로더에 대해 설명해주세요.(작성자 : 이영은)
    - 컴파일 타임이 아닌 런타임에 클래스를 로딩할 수 있게 해주는 기술입니다. 자바는 동적으로 클래스를 읽어오며 이때 클래스 로더를 사용합니다. 클래스 파일을 찾아서 로드 해놓는 역할을 합니다.

## Java 실행 엔진

- Java 실행엔진에 대해 설명해주세요. (작성자 : 이영은)
    - Runtime Data Area에 할당된 바이트코드를 실행시키는 주체입니다. CPU는 바이트 코드를 바로 실행할 수 없기에 실행엔진이 기계어로 변환하여 실행합니다. 코드를 실행하는 방식은 Interpreter와 JIT Compiler가 존재합니다. 


## 다양한 GC(parellel, g1gc 등)

- GC의 실행시점은? (작성자 : 이영은)
    - JVM의 Heap은 Young Generation, Old Generation으로 나뉘고, Young Generation은 다시 Eden, Servival 0, Servival 1 영역으로 나뉜다. Eden 영역이 꽉 차면 minor gc가 실행되어 Mark And Sweep 알고리즘을 통해 참조가 되고 있는 객체만 Servival 0 또는 Servival 1 영역으로 옮긴다.
    - 만약 여러 번 minor gc를 실행하고도 참조된 객체가 있다면 이 객체를 Servival 영역에서 Old Generation 영역으로 옮긴다. 시간이 지나서 Old Generation 영역이 꽉 차면 major gc를 실행하여 Mark And Sweep 알고리즘을 통해 필요 없는 메모리를 비운다.

## JRE, JDK, JVM의 구분

- JVM에 대해 설명해주세요. (작성자 : 이영은)
    - 자바 프로그램은 자바 컴파일러에 의해 자바 바이트 코드로 번역되는데, JVM은 OS를 대신해서 컴파일된 자바 바이트 코드를 실행하는 가상의 운영체제 역할을 합니다. 따라서, 자바 프로그램은 플랫폼에(=운영체제, CPU)에 종속되지 않습니다. 다만, JVM은 플랫폼에 의존하기 때문에 OS에 맞는 JVM을 설치해야 합니다.

## 자바 메모리관리(Xms, Xmx)

- Xmx 와 Xms 는 왜 지정해야 하는지 설명해주세요. (작성자 : 이영은)
    - JVM은 메모리가 부족하게 되면 OS에 메모리를 추가 요청하는 방식으로 힙 사이즈를 조정합니다. 이때 GC 가 발생하게 되고, JVM은 필요한 만큼 힙사이즈를 늘려가게 됩니다. 이렇게 조정하다가 만약 머신의 물리 메모리 사이즈를 넘어가게 되면 가상 메모리를 사용하면서 swap space로 swap in - out 을 하게 됩니다.


## Call by Value vs Call by Reference

- Call by value와 Call by reference의 차이에 대해 설명해주세요. (작성자 : 이영은)
    - Call by value는 메소드를 호출할 때 넘겨주고 싶은 변수(인자)를 지정하면, 메소드의 매개변수가 지정한 변수 값의 복사본으로 초기화되는 것이다.
    - Call by reference는 메소드를 호출할 때 넘겨주고 싶은 변수(인자)를 지정하면, 메소드의 매개변수가 지정한 변수의 레퍼런스로 초기화되는 것이다.


## Mutable, Immutable




## Auto Boxing & UnBoxing




## Error vs Exception 1



## Error vs Exception 2



## 비동기처리 문법 비교



## Java 8의 특징



## Lambda(+ Functional Interface)



## Stream API



## Default Method, 추상 클래스와 인터페이스



## Generic


## Reflection(Annotation)



## Collection Framework(List, Map, Set 등)



## HashMap



## CountDownLatch & CyclicBarrier


📚 출처

**객체지향**

- https://coldpresso.tistory.com/15
- [https://www.codestates.com/blog/content/객체-지향-프로그래밍-특징](https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95)


**Java 컴파일 과정**

- https://velog.io/@ka0ka0ka/1-3d8vtbh5

**클래스 로더**

- https://snow-line.tistory.com/125


**다양한 GC(parellel, g1gc 등)**

- https://steady-coding.tistory.com/584

**JRE, JDK, JVM의 구분**

- https://steady-coding.tistory.com/587

**자바 메모리관리(Xms, Xmx)**

- https://liltdevs.tistory.com/175

**Call by Value vs Call by Reference**

- https://steady-coding.tistory.com/613
