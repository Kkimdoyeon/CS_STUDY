# Generic

Generic은 '일반적'이라는 단어 뜻 그대로, **미리 지정한 타입에 구애받지 않고 필요에 따라 지정할 수 있는 타입**을 뜻한다. <br>

```
ArrayList list1 = new ArrayList();
String temp1 = (String) list.get(0);
String temp2 = (String) list.get(1);
...

// 일일히 타입 변환해줘야되나? 번거로운데 🤔

ArrayList<String> list2 = new ArrayList()<String>;
String temp3 =list.get(0);
String temp4 =list.get(1);

// ...😮!!
```

## Generic의 장점 
- 컴파일 단계에서 타입 에러가 나지 않는다
- 타입 관리가 편리하다

## Generic 구현

### Generic 종류

| 타입 | 설명    |
|------|---------|
| `<T>` | Type   |
| `<E>` | Element |
| `<K>` | Key    |
| `<V>` | Value  |
| `<N>` | Number |

### Generic 클래스 및 인터페이스 구현

```
public class ClassName <T> { ... }
public interface InterfaceName <T> { ... }
```
HashMap 같은 컬렉션의 경우 여러 타입이 필요할 수 있다. 
이 때 타입을 2개로 지정할 수도 있다. 
```
public class ClassName <T, K> { ... }
public interface InterfaceName <T, K> { ... }
```
이렇게 선언한 제너릭 클래스(인터페이스)는 객체 생성 단계에서 타입을 지정해 사용할 수 있다. 
```
public class Main {
	public static void main(String[] args) {
		ClassName<String, Integer> a = new ClassName<String, Integer>();
	}
}
```
이때 주의할 점은 제너릭에서는 **참조 타입**만 사용 가능하다. 원시 타입(int, double..)은 사용할 수 없다는 뜻이다. <br>
여기서 이전에 언급한 Wrapper가 나온다. 원시타입을 참조타입으로 변환해 제너릭에 사용할 수 있다. (Int, Double..)

### Generic 사용 

```
class ClassName<E> {
	
	private E element;	// 제네릭 타입 변수

	// Getter & Setter
}
class Main {
	public static void main(String[] args) {
		
		ClassName<String> a = new ClassName<String>();
		ClassName<Integer> b = new ClassName<Integer>();
		
	}
```

제너릭으로 선언된 클래스는 개발자가 자유롭게 타입을 지정해 사용할 수 있다. <br>

### Generic Method

위에서는 제너릭 클래스를 만들었다면 제너릭 메소드도 만들 수 있다. <br>
```
class ClassName<E> {
	
	private E element;	// 제네릭 타입 변수
	
  // Getter & Setter 
	
	<T> T genericMethod(T o) {	// 제네릭 메소드
		return o;
	}
}
```
이때 어떤 타입의 매개변수가 들어오냐에 따라 T의 타입이 결정된다. <br>
만약 제너릭 클래스가 String 타입으로 사용되었다 하더라도 제너릭 메소드의 파라미터에 Integer 타입이 들어가면 제너릭 메소드의 타입은 Integer다. <br>
제너릭 메소드는 static으로 선언해 클래스와 독립적으로 사용도 가능하다. <br>

### 제한된 Generic과 Wild Card

Generic의 타입을 자유롭게 지정할 수 있지만, 제한된 타입만 지정하고 싶을 수도 있다. <br>

```
<K extends T>	// T와 T의 자손 타입만 가능 (K는 들어오는 타입으로 지정 됨)
<K super T>	// T와 T의 부모(조상) 타입만 가능 (K는 들어오는 타입으로 지정 됨)
```

extends와 super을 사용해 지정 타입을 제한할 수 있다. <br>





























