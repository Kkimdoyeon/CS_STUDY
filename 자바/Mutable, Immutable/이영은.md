mutable 객체는 초기화 된 이후 변경이 가능하다. 하지만, immutable 객체는 초기화된 이후 변경이 불가능하다. 자바는 String을 제외하고 기본적으로 mutable 하다.

# Mutable 객체

가변 객체는 Java에서 Class의 인스턴스가 생성된 이후에 내부 상태가 변경 가능한 객체이다. 

가변 객체는 멀티 스레드 환경에서 사용하려면 별도의 동기화 처리가 필요하며, 대표적인 가변 객체로 ArrayList, HashMap, StringBuilder, StringBuffer 등이 존재한다. 

이외에도 프로그래머가 커스텀 객체를 생성하며 내부 상태를 변경할 수 있게 만든다면, 그것도 가변 객체가 된다.

# Immutable 객체

불변객체란 객체 생성 이후 내부의 상태가 변하지 않는 객체이다. 불변 객체는 read-only 메소드만을 제공하며, 멀티 스레드 환경에서도 안전하게 사용할 수 있다는 신뢰성을 보장한다. 

또한 객체의 내부 상태를 제공하는 메소드를 제공하지 않거나 방어적 복사를 통해 제공한다. Java의 대표적인 불변객체로는 String이 있다. 

```java
String name = "Old";
name.toCharArray()[0] = 'E';
```

Java의 String은 불변 클래스이기에 위와 같이 Strirng 내부의 char형 배열을 얻어 수정하여 반영이 되지 않는다. Java에서는 배열이나 객체 등의 참조를 전달한다. 그렇기에 참조를 통해 값을 수정하면 내부의 상태가 변하기에 내부를 복사하여 전달하고 있는데, 이를 방어적 복사라고 한다. String의 toCharArray를 다음과 같이 복사하여 전달하고 있다. 

```java
public char[] toCharArray() {
	char result[] = new char[value.length];
	System.arraycopy(value, 0, result, 0, value.length);
	return result;
}
```

### 불변 객체 및 final을 사용해야 하는 이유

1) Thread-safe 하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다. 

멀티 스레드 환경에서 동기화 문제가 발생하는 이유는 공유 자원에 동시 쓰기 연산 때문이다. 하지만 공유 자원 불변 객체라면, 항상 동일한 값만 반환하므로 동기화를 고려할 필요가 없다. 이는 안정성을 보장할 뿐만 아니라 동기화를 하지 않음으로써 성능 상의 이점을 가져다 준다. 

2) 실패 원자적인(Failure Atomic) 메소드를 만들 수 있다. 

가변 객체를 통해 어떠한 작업을 하는 도중 예외가 발생하면 해당 객체가 불안정한 상태에 빠질 수 있다. 그리고 불안정한 상태를 갖는 객체는 변경된 상태로 인해 새로운 에러를 유발할 수 있다. 하지만 불변 객체라면 어떠한 예외가 발생하여도 메소드 호출 전의 상태를 유지할 수 있으므로 예외가 발생하여도 변경된 상태로 인한 추가 에러를 막을 수 있다. 

3) Cache, Map, Set 등의 요소로 활용하기에 적합하다. 

만약 캐시나 Map 또는 Set 등으로 사용되는 객체가 변경되었다면 이를 갱신하는 등의 작업이 필요하다. 하지만 객체가 불변이라면 한 번 데이터가 저장된 이후에 다른 부가 작업을 고려하지 않아도 될 것이고, 이는 캐시나 다른 자료 구조를 사용하는데 용이하게 작용한다. 

4) 부수 효과(Side Effect)를 피해 오류 가능성을 최소화할 수 있다. 

부수 효과란 변수의 값이 변경되거나, 필드 값이 설정되는 등의 변화가 발생하는 효과를 의미한다. 만약 객체의 수정자(Setter)가 구현되어 있고, 여러 메소드에서 객체의 값이 변경된다면 객체를 예측하기 어려워진다. 

그래서 이러한 부수 효과가 없는 순수 함수를 만드는 것이 중요한데, 객체가 불변이라면?

불변 객체는 기본적으로 값의 수정이 불가능하므로 변경 가능성이 적으며 객체의 생성과 사용이 제한된다. 그러므로, 메소드들은 자연스럽게 순수 함수로 구성될 것이고, 다른 메소드가 호출되어도 객체의 상태가 유지되기 때문에 객체를 안전하게 재사용할 수 있다. 

이러한 불변 객체는 오류를 줄여 유지 보수성이 높은 코드를 작성하게 도와준다. 

5) 다른 사람이 작성한 함수를 예측 가능하며 안전하게 사용할 수 있다.

**6) 가비지 컬렉션의 성능을 높일 수 있다.** 

불변의 객체는 한번 생성된 이후에 수정이 불가능한 객체로, Java에서는 final 키워드를 사용하여 불변의 객체를 생성할 수 있다. 이렇게 객체를 생성하기 위해서는 객체를 가지는 또 다른 컨테이너 객체도 존재한다는 것인데, 당연히 불변의 객체가 먼저 생성되어야 컨테이너 객체가 이를 참조할 수 있을 것이다. 

즉, 컨테이너는 컨테이너가 참조하는 가장 젊은 객체들보다 더 늦게 생성되었다는 것이다. 

1. Object 타입의 value 객체 생성
2. ImmutableHolder 타입의 컨테이너 객체 생성
3. ImmutableHolder가 value 객체를 참조

이러한 점은 GC가 수행될 때, 가비지 컬렉터가 컨테이너 객체 하위의 불변 객체들은 Skip할 수 있도록 도와준다. 왜냐하면 해당 컨테이너 객체가 살아있다는 것은 하위의 불변 객체들 역시 처음에 할당된 상태로 참조되고 있음을 의미하기 때문이다. 

결국 불변의 객체를 활용하면 가비지 컬렉터가 스캔해야 되는 객체의 수가 줄어서 스캔해야 하는 메모리 영역과 빈도수 역시 줄어들 것이고, GC가 수행되어도 지연 시간을 줄일 수 있을 것이다. 그렇기 때문에 필드값을 수정할 수 있는 MutableHolder보다는 필드값을 수정할 수 없는 ImmuutableHolder를 사용하는 것이 좋다. 

📚 출처

- https://s-y-130.tistory.com/181
- https://cantcoding.tistory.com/41
- https://escapefromcoding.tistory.com/805