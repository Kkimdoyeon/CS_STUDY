# 다양한 GC(parellel, g1gc 등)

## 가비지 컬렉션 과정 - Generational Garbage Collection

**stop-the-world**

GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것

stop-the-world가 발생하면 GC를 실행하는 쓰레드를 제외하 나머지 쓰레드는 모두 작업을 멈춘다. 

어떤 GC알고리즘을 사용하더라도 stop-the-world는 발생한다.

대개의 경우 gc 튜닝이란 이 stop-the-world 시간을 줄이는 것이다.

GC는 두 가지 가설 아래에서 만들어졌다.

- 대부분의 객체는 금방 접근 불가능 상태가 된다.
- 오래된 객체에서는 젊은 객체로의 참조는 아주 적게 존재한다.

이러한 가설의 장점을 최대한 살리기 위해 크게 Young과 Old 영역으로 물리적 공간을 나누었다. 

Young 영역 : 새롭게 생성한 객체의 대부분이 여기에 위치한다. 대부분의 객체가 금방 접근 불가능 상태가 되기 때문에 매우 많은 객체가 Young 영역에 생성되었다가 사라진다. 이 영역에서 객체가 사라질때, Minor GC가 발생한다고 말한다. 

Old 영역 : 접근 불가능한 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당되며, 크기가 큰 만큼 Young영역보다 GC는 적게 발생한다. 이 영역에서 객체가 사라질 때, Major GC가 발생한다고 말한다.

### Young 영역의 구성

1개의 Eden 영역과 2개의 Survivor 영역으로 나뉜다. 

**각 영역의 처리 절차를 순서**

- 새로 생성한 대부분의 객체는 Eden 영역에 위치한다.
- Eden 영역에서 GC가 한 번 발생한 후, 살아남은 객체는 Survivor 영역 중 하나로 이동된다.
- Eden 영역에서 GC가 발생하면 이미 살아남은 객체가 존재하는 Survivor 영역으로 객체가 계속 쌓인다.
- 하나의 Survivor 영역이 가득 차게 되면 그 중에서 살아남은 객체를 다른 Survivor 영역으로 이동한다. 그리고 가득한 Survivor 영역은 아무 데이터도 없는 상태로 된다.
- 이 과정을 반복하다가 계속 살아남은 객체는 Old영역으로 이동하게 된다.

***Survivor  영역 중 하나는 반드시 비어 있는 상태로 남아 있어야 한다.***

### Old 영역에 대한 GC

Old 영역은 기본적으로 데이터가 가득차면 GC를 실행한다. 

1) Serial GC

- 운영서버에서 절대 사용하면 안되는 방식 - 데스크톱의 CPU 코어가 하나만 있을 때 사용하기 위해서 만든 방식
- mark-sweep-compact 알고리즘 사용
    1. Old 영역에 살아있는 객체 식별(mark)
    2. 힙의 앞 부분부터 확인하여 살아있는 것만 남김(sweep)
    3. 각 객체들이 연속되게 쌓이도록 힙의 가장 앞 부분부터 채워서 객체가 존재하는 부분과 객체가 없는 부분으로 나눈다(compact)
- 적은 메모리와 CPU 코어개수가 적을 때 적합한 방식

2) Parallel GC

- mark-sweep-compact 알고리즘 사용
- 그러나 serial GC는 쓰레드가 하나이지만, Parallel GC는 GC를 처리하는 쓰레드가 여러 개이다. 그렇기에 Serial GC보다 빠르게 객체를 처리할 수 있다.
- 메모리가 충분하고 코어의 개수가 많을 때 유리하다.

3) Parallel Old GC

- mark-summary-compaction 단계를 거친다.
- summary 단계는 gc를 수행한 영역에 대해서 별도로 살아 있는 객체를 식별한다는 점에서 mark-sweep-compaction 알고리즘의 sweep 단계와 차이가 있다.

4) CMS GC

![img](img/ye_cmsgc.png)

1. Initial Mark 단계 : 클래스 로더에서 가장 가까운 객체 중 살아있는 객체만 찾는 것으로 끝나기에, 멈추는 시간이 굉장히 짧다.
2. Concurrent Mark 단계 : 방금 살아있다고 확인한 객체에서 참조하고 있는 객체들을 따라가면서 확인한다. 다른 스레드가 실행중인 상태에서 동시에 진행됨
3. Remark  단계 : Concurrent Mark 단계에서 새로 추가되거나 참조가 끊긴 객체를 확인한다. 
4. Concurrent Sweep 단계 : 쓰레기를 정리하는 작업을 실행한다. 
- 장점
    - stop-the-world 시간이 매우 짧음
    - 모든 애플리케이션의 응답속도가 중요할 때 사용
- 단점
    - 다른 gc방식보다 메모리와 cpu를 더 많이 사용한다.
    - Compaction 단계가 기본적으로 제공되지 않는다.

5) G1 GC

![img](img/ye_g1.png)

- 바둑판의 각 영역에 객체를 할당하고, gc를 실행한다. 그러다가 해당 영역이 꽉 차면 다른 영역에서 객체를 할당하고, gc를 실행한다.
- CMS GC를 대체하기 위해서 고안됨
- 가장 큰 장점은 성능이다. 가장 빠른 GC,
- 아직 안정화 단계는 아님

📚 출처

- https://d2.naver.com/helloworld/1329