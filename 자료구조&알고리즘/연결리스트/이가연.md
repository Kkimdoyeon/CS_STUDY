# 연결리스트

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/fd165359-a1aa-4ebc-a7da-48c05212436d)

>연결리스트(Linked List)는 각 노드가 데이터와 포인터를 가지고 한 줄로 연결되어 있는 방식으로 데이터를 저장하는 자료구조이다.
>
>이때 포인터는 **다음 노드의 주소**를 갖고 있다.


## 삽입, 삭제, 탐색
- ### 삽입
  - **연결리스트가 비어있는 경우**
    
    
      head가 newNode를 가리키게 한다. 이때 head==null이라면 연결리스트가 비어있다는 뜻이다. 
  - **연결리스트가 비어있지 않은 경우**
 
      - 맨앞에 삽입할 때
        
        ![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/34f255ef-8cb4-423f-aaa4-3389dc1705ea)
        
          head가 가리키는 노드(맨앞 노드)를 newNode가 가리키게 한 뒤 head가 newNode를 가리키게 수정한다.
      - 중간에 삽입할 때
        ![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/a96bc0c6-782d-455b-ad97-a12c39652399)
      
          a 노드와 b 노드 사이에 삽입하고자 할 때, a노드가 가리키는 노드를 newNode가 가리키게 한 뒤
        
          a 노드가 newNode를 가리키게 수정한다.

      - 맨뒤에 삽입할 때
   
        ![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/930f20ef-9c7b-46c6-b680-4e0ef87a36b3)

        마지막 노드가 newNode를 가리키게 한다.
 
       ### 삽입 코드 ###

        void insert(int data){
          Node* ptr;
          Node* newNode = (Node*)malloc(sizeof(Node));    // newNode 할당 
          newNode->data = data;    // 데이터 할당 
          newNode->next = NULL;    // next 포인터 초기화

            if(head == NULL){    // empty
                head = newNode;
            }else{
                if(head->data > newNode->data){    // not empty, 가장 앞에 노드 추가 
                    newNode->next = head;
                    head = newNode;
                    return;
                }

- ### 삭제
  - 맨앞 삭제
    ![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/c80fb6a1-f5fc-406a-81dc-7a952181d65f)

    head 가 cur->next를 가리키게 하고, cur->next를 NULL 로 설정한다.

    그 뒤 cur을 free 해준다.

  - 중간 또는 맨뒤 삭제
    ![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/855b25cd-359e-4e68-a920-a3fc23122f0a)

    새로운 포인터(prev)가 필요하다.

    먼저 prev와 cur이 head를 가리키게 한 뒤,

    cur을 뒤로 보내다 삭제하려는 데이터와 일치하면

    prev->next를 cur->next를 가리키게 하고

    cur->next를 null로 수정한 뒤 free 해준다.
 
    ### 삭제 코드 ###
    ```
    int deleteNode(int data){
    Node *cur, *prev;
    cur = prev = head;
    
    if(head == NULL){    // empty list 
        printf("error: list is empty!\n");
        return -1;
    }        
    
    if(head->data == data){    // 가장 앞의 노드 삭제
        head = cur->next;
        cur->next = NULL;
        free(cur);
        return 1;
    }
    
    for(; cur; cur= cur->next){    // 중간 혹은 마지막 노드 삭제
        if(cur->data == data){
            prev->next = cur->next;
            cur->next = NULL;
            free(cur);
            return 1;
        }
        prev = cur;
    }
    
    printf("error : there is no %d!\n", data);
    return -1;    // 해당 데이터가 리스트에 존재하지 않음 
    }

- ### 탐색
  ```
  int search_list(int data){
    Node* ptr;
    for(ptr = head ; ptr ; ptr=ptr->next){
        if(ptr->data == data){    // data 발견  
            return 1;
        }
    }
    
    return -1; // 데이터 미 발견 
  }
<br><br><br>
## 단방향, 양방향, 이중, 원형 연결리스트
<br><br>
## Java에서의 연결리스트 구현 
<br><br>
##### 출처
https://code-lab1.tistory.com/2 (코드연구소님의 게시물을 참고하여 작성한 게시물입니다.)
