# 연결리스트

연결리스트는 선형리스트의 논리적인 순서와 메모리내의 물리적인 순서가 일치하지 않는다.

연결리스트는 순서리스트에서 임의의 위치에 있는 항목을 삭제하거나 삽입할 때 데이터들의 대이동이 일어나지 않는 선형구조이다. 

임의의 원소의 값을 수정하는 연산이 일어날 경우 많은 탐색시간을 필요로 한다. 

포인터만큼의 기억공간의 낭비가 발생한다. 

---

## 연결리스트의 종류

1) 단일 연결리스트

단일 연결 리스트는 각 노드에 자료 공간과 한 개의 포인터 공간이 있고, 각 노드의 포인터는 다음 노드를 가리킨다. 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f609fde2-df22-4d31-ae5f-8cfe2e9e4966/2c98b66d-a250-444e-9734-9a4ca667261e/Untitled.png)

2) 이중연결리스트

- 단순연결리스트는 next로 현재 노드에서 다음 노드로 갈 수 있지만, 이전 노드로는 갈 수 없습니다.
    
    이러한 단점을 해결하기 위해 노드에 앞 노드의 메모리 주소를 보관하는 포인터 prev를 만들어준 형태를 이중 연결 리스트 입니다. 
    
- 임의 노드의 포인터가 파괴되었을 때 복구가 가능하다.
- 2개의 포인터에 의한 메모리 낭비가 발생한다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f609fde2-df22-4d31-ae5f-8cfe2e9e4966/059bdfa9-8f7d-4d17-983d-b244c3e3eecd/Untitled.png)
    

3) 원형 연결 리스트

- 원형 연결 리스트는 단순 연결 리스트의 마지막 노드의 포인터가 null이 아닌 헤드를 가리키는 형태의 리스트 입니다.
    
    따라서 리스트의 끝이 존재하지 않습니다. 
    
- 마지막 노드와 첫번째 노드는 이웃 노드가 됩니다.
- 한 노드에서부터 다른 어떤 노드로도 접근할 수 있습니다.
- 헤드가 마지막 노드를 가리키는 것이 원형큐 구현을 수행할 때 더 효율적입니다.
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f609fde2-df22-4d31-ae5f-8cfe2e9e4966/e1701544-27e9-4df8-9bdb-575f6f6839df/Untitled.png)
    

---

## 시간복잡도

1) 접근 시간 복잡도 : O(n)

- 인덱스 x에 있는 노드에 접근하려면 Head에서 다음 노드로 x번 가면 된다.
- 마지막 노드에 접근하려면 Head에서 다음 노드로 n-1번 가야된다.
- 최악의 경우 시간 복잡도 : O(n)

2) 탐색 시간 복잡도 : O(n)

- 배열을 탐색할 때와 같은 방법으로 구한다.
- 가장 앞 노드부터 다음 노드를 하나씩 보면서 원하는 데이터를 갖는 데이터를 찾는다. 이를 선형 탐색이라고 한다.
- 링크드 리스트 안에 찾는 데이터가 없거나 또는 찾으려는 데이터가 마지막 노드에 있는 경우 n개의 노드를 다 봐야 한다.
- 최악의 경우 시간 복잡도 : O(n)

3) 삽입 / 삭제 시간 복잡도 : O(1)

- 삽입, 삭제할 노드의 주변 노드들의 Link만 수정하면 된다.
- 따라서, 삽입, 삭제가 실행되는 시간은 특정 값에 비례하지 않고 항상 일정하다.

 

---

## 면접질문

- Array와 ArrayList의 차이점에 대해 설명해주세요
    - Array는 크기가 고정적이고, ArrayList는 크기가 가변적입니다.
    - Array는 초기화 시 메모리에 할당되어 ArrayList보다 속도가 빠르고, ArrayList는 데이터 추가 및 삭제 시 메모리를 재할당하기 때문에 속도가 Array보다 느립니다.
- Array와 LinkedList의 장 / 단점에 대해 설명해주세요
    - Array는 인덱스로 해당 원소에 접근할 수 있어 찾고자 하는 원소의 인덱스 값을 알고 있으면 O(1)에 해당 원소로 접근할 수 있습니다. 즉 RandomAccess가 가능해 속도가 빠르다는 장점이 있습니다. 하지만 삽입 또는 삭제의 과정에서 각 원소들을 이동해줘야 하는 비용이 생겨 이 경우 시간복잡도는 O(n)이 된다는 단점이 있습니다.
    - 이 문제점을 해결하기 위한 자료구조가 LinkedList입니다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있기 때문에 이 부분만 다른 값으로 바꿔주면 삽입과 삭제를 O(1)으로 해결할 수 있습니다. 하지만 LinkedList는 원하는 위치에 한 번에 접근할 수 없다는 단점이 있습니다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 Search과정에 있어서 첫번째 원소부터 다 확인해봐야 합니다.
    - 간단히 정리하면, Array는 검색이 빠르지만, 삽입과 삭제가 느립니다. LinkedList는 삽입과 삭제는 빠르지만, 검색이 느립니다.

📚 출처

https://hyeinisfree.tistory.com/64

https://dev-coco.tistory.com/159