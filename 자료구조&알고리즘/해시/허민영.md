# 해시(Hash) == 해시값 == 해시코드 == 체크섬
입력 데이터를 고정된 길이의 데이터로 변환된 값이며, 해시 함수에 의해 얻게 되는 값이다.


즉, 데이터의 KEY값이 해시 함수를 통해서 변환된 간단한 정수

# 활용

배열의 인덱스 위치
데이터 값 저장 or 검색


# 특징
1. 키(KEY)에 데이터(Value)를 매핑할 수 있는 데이터 구조
2. 해시 함수를 통해 키의 데이터를 배열에 저장할 수 있는 주소(인덱스 번호)를 계산
3. 키를 통해서 저장된 데이터를 빠르게 찾고, 저장 및 탐색 속도가 획기적으로 빨라짐

# 용어

## 1) 해시 함수(Hash Function)
    임의의 데이터를 고정된 길이의 값으로 리턴해주는 함수

해시 함수는 입력받은 데이터를 해시값으로 출력시키는 알고리즘

이렇게 출력된 해시 값은 알고리즘에 따라 다양한 결과를 보인다.
그렇기 떄문에 함수는 목적에 맞게 다양하게 설계되고 자료구조, 캐시, 검색, 에러검출, 암호 등으로 유용하게 사용된다.

## 2) 해시 테이블(Hash Table)
    키 값의 연산에 의해 직접 접근이 가능한 데이터 구조

해시 테이블은 키와 값을 함께 저장해 둔 데이터 구조.
표와 유사하다.
테이블에 데이터를 저장할 때 위치는 무작위로 지정되어 작성된다.
따라서 중간에 여유 공간이 발생할 수 있다.



## 3) 해싱(Hashing)

    해싱은 해시 함수에서 해시를 출력하고, 해시 테이블에 저장하는 과정까지의 행위

## 4) 해시 자료구조의 장, 단점과 용도

### 장점 
    - 데이터 저장/ 읽기 속도가 빠름(검색 속도가 빠름)
    - 해시는 키에 대한 데이터가 있는지 확인이 쉬움

### 단점
    - 일반적으로 저장공간이 많이 필요
    - 여러 키에 해당하는 주소(인덱스)가 동일한 경우 충돌을 해결하기 위한 별도의 자료구조 필요


### 주요 용도
- 검색이 많이 필요한 경우
- 저장, 삭제, 읽기가 빈번한 경우
- 캐쉬 구현



# 해시 구현

```java
// 기본적인 해시 테이블 구현
public class Hash {

    // Hash table
    public Slot[] hashTable; // 배열 형태로 선언

    // Hash 객체를 생성할 때 table 사이즈 지정
    public Hash(Integer size) {
        this.hashTable = new Slot[size];
    }

    // Slot에는 value를 가짐
    public class Slot {

        String value;

        Slot(String value) {
            this.value = value;
        }
    }

    //Hash function
    public int hashFunction(String key) {
        return (int) (key.charAt(0)) % this.hashTable.length; // 나머지
        //입력받은 키의 첫번째 문자를 배열의 크기로 나눈 나머지를 인덱스로 사용
    }

    // 입력 받은 key를 해시 함수로 인덱스화 하고, 해당 인덱스에 value 저장
    public boolean saveData(String key, String value) {

        // key는 해시 함수를 거쳐서 해시 값(해시, 해시 주소)을 반환 -> 여기선 배열의 index와 동일
        Integer address = this.hashFunction(key);

        if (this.hashTable[address] != null) { // 해당 주소에 이미 데이터가 있을 경우
            this.hashTable[address].value = value;
        } else {
            this.hashTable[address] = new Slot(value);
        }

        return true;
    }

    // key에 해당하는 값을 반환
    public String getData(String key) {

        // key는 해시 함수를 거쳐서 해시 값(해시, 해시 주소)을 반환
        Integer address = this.hashFunction(key);

        if (this.hashTable[address] != null) {
            return this.hashTable[address].value;
        } else {
            return null;
        }
    }
}
```

# 충돌(Collision)

만약 해시테이블에 존재하는 기존 키와 동일한 첫번째 문자를 가진 키가 있다면 해시 함수에서의 반환 인덱스 값이 동일할 것이다.
그럼 배열의 같은 장소에 저장되고, 이전에 저장된 정보는 사라진다.
이를 충돌이 발생했다라고 한다.


## 충돌이 일어나는 이유?

1) 함수 알고리즘의 성능이 좋지 못할 때
2) 저장되는 데이터 양이 해시 테이블 크기보다 클 때


# 충돌 해결법

## 1) Chaining기법
    - 해시 테이블 저장공간 외의 공간을 활용하는 기법
    - 충돌이 발생했을 때, 연결 리스트 자료구조를 사용해서 해결하는 방법
    
    - 장점: 연결리스트만 사용하면 된다.


## 2) Open Addressing
    충돌 발생 시 해시 함수로 얻은 주소가 아닌 다른 주소 공간에 데이터 저장 

    - 체이닝처럼 포인터가 필요없고, 지정한 메모리 외 추가적인 저장공간도 필요 없다.
    - 저장할 데이터가 적을 때 더 유리
    - 삽인 삭제 시 오버헤드가 적음.

## 2-1) 선형 프로빙 (Linear Probing) 기법
    해시 함수로 나온 해시 값(index)에 이미 다른 값이 저장되어 있다면, 해당 해시값에서 고정된 폭만큼 옮겨 다음 빈칸을 찾아가는 방법.

### 해시 함수
#### h(k,i) = (h'(k) + i) mod m  / k: 키 , i: 충돌 횟수 h() : 해시 함수, m: 해시 테이블 크기


### 장단점

### 장점
    구현이 쉬움
  
### 단점

    특정 해시 값의 주변이 모두 채워져 있는 일차 군집화(primary clustering) 문제가 발생 -> 평균 검색 시간 증가
         2~6까지 데이터가 모여있는 것을 확인할 수 있는데, 모든 키가 2라는 값으로 해시값이 나올 경우 
         군집화 된 값들을 순차적으로 방문할 텐데 해시 성능이 크게 저하될 수 있다.

## 2-2) 이차식 프로빙 (Quadratic probing) 기법
해시충돌 시 제곱만큼 건너뛴 버켓에 데이터를 삽입(1,4,9,16..)

### 해시 함수
#### h(k,i) = (h'(k) + c1i + c2i^2) mod m  / k: 키 , i: 충돌 횟수 h() : 해시 함수, m: 해시 테이블 크기

### 장단점
### 장점
    데이터의 밀집도가 선형 탐사법보다 낮기 때문에 다른 해시값까지 영향을 받아서 연쇄적으로 충돌이 발생할 가능성이 적음.

### 단점
    단점: 선형 탐사법보다는 캐시의 성능이 떨어져서 속도의 문제가 발생


## 2-3) 이중 해시(Double hasing) 기법

해시충돌 시 다른 해시함수를 한 번 더 적용한 결과를 이용함.

하나는 처음의 key를 저장할 index를 찾기 위한 것이고,

나머지 하나는 충돌 발생 시 저장할 index를 찾기 위한 것이며, 충돌 발생 시 저장할 index를 찾기 위한 해시 함수는 첫 번째 해시 함수와 달라야 한다.


### 해시 함수
#### h(k,i) = (h1(k) + i(h2(k))) mod m  / k: 키 , i: 충돌 횟수 h() : 해시 함수, m: 해시 테이블 크기
충돌이 없을 때는 h1으로 위치를 탐색하고, 충돌이 있으면 h2 mod m 만큼 이동하면서 탐색한다.

### 장단점

### 장점
    충돌의 발생 가능성은 가장 적음.

### 단점
    1. 캐시의 성능은 Linear Probing, Quadratic Probing과 비교했을 때 가장 좋지 않음.
    2. 추가적인 해시 연산이 들어가서 가장 많은 연산량 요구





# 시간 복잡도

- 충돌이 없는 경우 : O(1)
- 최악의 경우: 모든 index에서 충돌이 발생하는 경우 O(n)

충돌을 방지하는 방법들은 데이터의 규칙성(클러스터링)을 방지하기 위한 방식이지만 공간을 많이 사용한다는 치명적인 단점이 있다.

만약 테이블이 꽉 차있는 경우라면 테이블을 확장해주어야 하는데, 이는 매우 심각한 성능의 저하를 불러오기 때문에 가급적이면 확정을 하지 않도록 테이블을 설계해주어야 한다.

(통계적으로 해시 테이블의 공간 사용률이 70% ~ 80%정도가 되면 해시의 충돌이 빈번하게 발생하여 성능이 저하되기 시작한다고 한다.)

또한 해시 테이블에서 자주 사용하게 되는 데이터를 Cache에 적용하면 효율을 높일 수 있다. 
자주 hit하게 되는 데이터를 캐시에서 바로 찾음으로써 해시 테이블의 성능을 향상시킬 수 있다.

## Java의 HashMap(해시 맵)과 HashTable(헤시 테이블) 차이

### **동기화 지원 여부**

동기화 지원 여부와 null 값 허용 여부의 차이

- 해시 테이블(Hash Table)
  - 병렬 처리를 할 때 (동기화를 고려해야 하는 상황) Thread-safe 함. 
  - Null 값을 허용하지 않음.


- 해시 맵(Hash Map)
  - 병렬 처리를 하지 않을 때 (동기화를 고려하지 않는 상황) Thread-safe하지 않음.
  - Null 값을 허용함.

**그렇기 때문에 우리는 병렬처리를 하면서 자원의 동기화를 고려해야하는 상황이라면 해시테이블을
병렬 처리를 하지 않거나 자원의 동기화를 고려하지 않는 상황이라면 해시맵을 사용하면 된다.**
