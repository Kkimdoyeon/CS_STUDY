# 그리디 알고리즘(탐용법, Greedy Algorithm)

최적의 값을 구해야 하는 상황에서 사용되는 **근시안적인 방법론**으로 '각 단계에서 최적이라고 생각되는 것을 선택'해 나가는 방식으로 진행하여 최종적인 해답에 도달하는 알고리즘

    이때, 항상 최적의 값을 보장하는 것이 아니라 최적의 값의 '근사한 값'을 목표로 하고 있다.

- 주로 문제를 분할 가능한 문제들로 분할한 뒤, 각 문제들에 대한 최적해를 구한 뒤 이를 결합하여 전체 문제의 최적해를 구하는 경우에 주로 사용된다.

### 근시안적 방법론?
    단기적인 목표를 중심으로 한 전략적인 접근 방법을 의미
    이 방법론은 주로 현재의 문제를 해결하는 데 초점을 맞추며, 장기적인 전망보다는 단기적인 성과를 중요시한다.


### 근사 알고리즘?
    최적의 해를 구할 수 없는 문제에서 근사한 해를 구하는 알고리즘을 의미한다.
    근사 알고리즘은 항상 최적해를 보장하지는 않지만, 많은 경우에는 최적해에 근접한 값을 구할 수 있다.

# 그리디 알고리즘 주요 속성

## 1) 탐욕 선택 속성
    각 단계에서 최선의 선택을 했을 때 전체 문제에 대한 최적해를 구할 수 있는 경우
    즉, 각 단계에서 가장 이상적인 선택을 하는 것이 전체적으로 최적의 결과를 가져온다는 것

## 2) 최적 부분 구조
    전체 문제의 최적해가 부분 문제의 최적해로 구성 될 수 있는 경우
    
    즉, 전체 문제를 작은 부분 문제로 나누어 각각의 부분 문제ㅔ에서 최적의 해를 구한 후
    이를 조합하여 전체 문제의 최적해를 구하는 것을 의미

## 3) 그리디 알고리즘 단계
    매 단계마다 최적이라고 생각되는 선택을 하면서 최종적으로 전체적으로 최적인 해답을 찾아내는 과정

### 그리디 알고리즘 단계

1. 문제의 최적해 구조를 결정한다.
2. 문제의 구조에 맞게 선택 절차를 정의한다. : 선택 절차
3. 선택 절차에 따라 선택을 수행한다.
4. 선택된 해가 문제의 조건을 만족하는지 검사한다. : 적절성 검사
5. 조건을 만족하지 않으면 해당 해를 제외한다.
6. 모든 선택이 완료되면 해답을 검사한다. : 해답 검사
7. 조건을 만족하지 않으면 해답으로 인정되지 않는다.

### 3-1) 선택 절차
    이 단계에서는 '현재 상태'에서 '최적인 선택'을 한다.
    이 선택은 이후에 바뀌지 않는다.

### 3-2) 적절성 검사
    선택한 항목이 '문제의 조건'을 만족시키는지 확인한다.
    조건을 만족시키지 않으면 해당 항목은 제외된다.

### 3-3) 해답 검사
    모든 선택이 완료되면, '최종선택'이 문제의 조건을 만족시키는지 확인한다.
    조건을 만족시키면 해답으로 인정된다.


## 예)

💡 문제 확인

- 거스름돈으로 1260원을 거슬러줘야 할 때 500원, 100원, 50원, 10원짜리 동전이 무한정 존재한다면, 가장 큰 동전부터 가능한 많이 사용하는 방식으로 거스름돈을 계산해 줍니다.

💡 그리디 알고리즘 적용

- 해당 문제에서 그리디 알고리즘을 적용한다면 아래와 같다.

1. 선택 절차 : 거스름돈 문제에서 가장 가치가 큰 동전부터 선택한다.
2. 적절성 검사: 만약 선택된 동전의 가치가 거스름돈보다 크다면 다음으로 작은 동전을 선택한다.
3. 해답 검사 : 합이 일치하면 거스름돈 문제가 해결된다.
```java
public ResponseEntity<ApiResponse<Object>> changeMoney() {

    Integer[] coins = {100, 10, 500, 50};   // 동전 종류
    int money = 1260;                       // 거스름돈
    int count = 0;                          // 동전 사용 개수

    Map<String, Object> resultMap = new HashMap<>();

    // 1. 선택 절차 적용 : 거스름돈 문제에서 가장 가치가 큰 동전부터 선택을 합니다.
    Arrays.sort(coins, Comparator.reverseOrder());

    // 2. 적절성 검사 : 만약 선택된 동전의 가치가 거스름돈보다 크다면 다음으로 작은 동전을 선택한다.
    for (int i = 0; i < coins.length; i++) {
        count += money / coins[i];
        money %= coins[i];
        resultMap.put(String.valueOf(coins[i]), count);
    }
    // 3. 해답 검사 : 합이 일치하면 거스름돈 문제가 해결되었습니다.
    if (money == 0) {
        System.out.println("거스름돈 문제가 해결되었습니다.");
    }

    // 결과값 : { "500" : 2, "100" : 4, "50" : 5, "10": 6 }

    ApiResponse<Object> ar = ApiResponse.builder()
            .result(resultMap)
            .resultCode(SUCCESS_CODE)
            .resultMsg(SUCCESS_MSG).build();
    return new ResponseEntity<>(ar, HttpStatus.OK);
}
```