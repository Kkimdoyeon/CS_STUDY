# 자료구조&알고리즘 면접 예상질문 

## 정렬

- 버블 정렬에 대해 설명해주세요

  > 배열의 인접한 두 원소를 비교해 위치를 조정하며 최대값 맨뒤로 보낸 뒤 <br>정렬되지 않은 나머지 배열에 대해 정렬이 완료될 때까지 반복하는 알고리즘입니다.<br>
  > 시간 복잡도는 최선/최악의 경우 모두 O(n^2)로 비효율적인 알고리즘입니다.
- 선택 정렬에 대해 설명해주세요
  > 배열에서 최대값을 뽑아 맨 뒤로 보낸 뒤 <br>정렬되지 않은 나머지 배열에 대해 정렬이 완료될 때까지 반복하는 알고리즘입니다.<br>
  > 시간 복잡도는 최선/최악의 경우 모두 O(n^2)로 비효율적인 알고리즘입니다.
- 삽입 정렬에 대해 설명해주세요
  > 정렬된 배열과 정렬되지 않은 배열로 나누어 <br>정렬되지 않은 배열의 원소를 차례차례 정렬된 배열의 올바른 위치에 삽입하는 알고리즘입니다.<br>
  > 시간 복잡도는 최선의 경우 O(n)이고 최악의 경우 O(n^2)로 배열이 정렬돼있을수록 효율적인 알고리즘입니다.
- 병합 정렬에 대해 설명해주세요
  > 부분 배열의 크기가 1이 될 때까지 분할한 뒤 부분 리스트를 재귀적으로 병합하는 알고리즘입니다.<br>
  > 시간 복잡도는 최선/최악의 경우 모두 O(nlogn)이나 병합을 위한 추가 배열의 메모리가 소요됩니다.
- 퀵 정렬에 대해 설명해주세요
  > 피벗을 지정해 이를 기준으로 재귀적으로 정렬하는알고리즘입니다. <br>이때 피벗이 두 개인 정렬을 듀얼 피벗 알고리즘이라 합니다.<br>
  > 시간 복잡도는 최선/최악의 경우 모두 O(nlogn)으로 항상 효율적인 알고리즘입니다.
- 힙 정렬에 대해 설명해주세요
  > 배열이 정렬될 때까지 힙으로 만들고 루트를 꺼내 저장을 반복하는 알고리즘입니다.<br>
  > 시간 복잡도는 최선/최악의 경우 모두 O(nlogn)으로 항상 효율적인 알고리즘이며 <br>특히 가장 큰 값 몇 개를 꺼낼 때 유용합니다.
  
- 계수 정렬에 대해 설명해주세요
  > 각 숫자가 몇 개 있는지 개수를 세어 저장한 후 정렬하는 알고리즘입니다.
  > 정렬하고자하는 배열의 최댓값을 구한 후 최댓값 크기의 배열에 각 원소를 순회하며 해당 값이 몇 개인지 저장하고 저장된 데이터를 순서대로 출력합니다.
  
- 왜 삽입 정렬이 평균 O(N^2) 시간 복잡도를 갖는 알고리즘들 중에서 가장 빠를가요?
  >삽입 정렬은 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘입니다. 따라서 삽입할 위치까지만 탐색하면 되기 때문에 선택 정렬과 버블정렬에 비해 빠릅니다.
  또한 이미 정렬이 된 경우 한번씩만 비교하면 되므로 O(N)시간 복잡도를 갖습니다.

- Quick Sort의 특징과 시간복잡도에 대해 설명해주세요.
  >퀵소트는 기준 데이터 pivot을 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꿔 정렬하는 알고리즘입니다. 추가적인 메모리를 필요로하지 않습니다. 시간복잡도의 경우 피봇이 정확히 데이터를 절반씩 나눈다면 평균적으로 O(NlogN)에 정렬이 가능하지만, 피봇이 데이터를 1개씩만 나눈다면 최악의 경우 시간복잡도는 O(N^2)가 됩니다.

- Quick Sort 성능 개선 기법으로는 어떤게 있나요?
  > 3가지 방법을 알고있습니다. 하나는 피복을 맨 처음 값으로 하면 최악의 경우 O(N^2)의 시간 복잡도를 가지므로 랜덤으로 피봇을 설정하도록 하는 것입니다.
  또는 맨 앞과 중간 맨 뒤 값을 우선적으로 정렬하고 중앙값을 피봇으로 삼는 경우입니다.
  마지막으로는 삽입정렬과 함께 사용하는 방법입니다. 만약 배열의 크기가 특정 수 이하라면 삽입정렬, 특정 수보다 크면 퀵정렬을 사용하여 정렬하는 방식입니다.
  퀵소트는 거의 정렬된 상태에서 성능이 매우 떨어진다는 점을 고려해 정렬된 배열에서 좋은 성능을 발휘하는 삽입정렬을 사용하면 어느정도 성능 하락을 방지할 수 있습니다.

- 54321 배열이 있을 때, 어떤 정렬을 사용하면 좋을까요?
  > 이미 내림차순으로 정렬되어 있기 때문에, 사용 목적에 따라 인덱스를 역순으로 접근하면 가장 시간적 효율이 높다고 생각합니다.
  그럼에도 정렬을 해야 한다면, 가장 빠른 시간복잡도로 알려진 힙 정렬이나 병합 정렬을 사용할 것 같습니다.

- 정렬을 하는 이유는 무엇인가요?
  >데이터를 탐색하기 위해서 합니다. 정렬이 되어있다면 이진탐색을 할 수 있기 때문입니다.

- 랜덤으로 배치된 배열이 있을때, 어떤 정렬을 사용하면 좋을까요
  > 배열의 상태에 구애받지 않고 일정한 시간 복잡도를 가진 힙 정렬이나 병합 정렬을 사용할 것 같습니다.

- 언제 불안정 정렬을 쓰면 안될까요?
  > 기존의 정렬을 유지해야할 때 입니다.
  > A,B 쌍인데 B는 이미 정렬상태로 입력되는 상황이 벌어지면 기존의 정렬이 깨지기 떄문입니다.

- 자릿수가 모두 같은 수가 담긴 배열이 있을 때, 어떤 정렬을 사용하면 좋을까요?
  > 공간 복잡도가 높아지기는 하지만, 기수 정렬을 사용하는 것이 시간적으로 효율이 가장 높다고 생각합니다. 
  > 기수 정렬은 일의 자리부터 순서대로 자릿수 별로 버킷에 담는 방식으로, 
  > 최대 자릿수 만큼만 반복하면 되기 떄문에 빠르게 정렬이 가능합니다.



## 해시
- 해시테이블과 시간복잡도에 대해 설명해주세요
    - 해시테이블은 키와 밸류의 쌍 형태로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조입니다.
    - 빠른 검색 속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문입니다.
    - 각 키값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 O(1)의 시간 복잡도로 데이터를 조회합니다. 하지만 index값이 충돌이 발생한 경우 Chaninging에 연결된 리스트들까지 검색해야 하므로 O(N)까지 증가할 수 있습니다.


- 해시 맵과 해시 테이블의 차이점에 대해 설명해주세요
    - 동기화 지원 여부와 null값 허용 여부의 차이가 있습니다.
    - 해시테이블은 병렬처리를 할 때, 즉 동기화를 고려해야 하는 상황에서 Thread-safe합니다. 또한 null값을 허용하지 않습니다.
    - 해시맵은 병렬처리를 하지 않을 때, 즉 동기화를 고려하지 않는 상황일 때 Thread-safr 하지 않으며, null값을 허용합니다.


- 값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?
    - 충돌이 최대한 적은 해시 함수를 설계하기 위해서는 두가지 방법이 있습니다.
    - 첫째, 입력 데이터의 가능한 모든 값 범위를 고려하여 해시 함수의 출력 범위를 균등하게 분포시키는 것이 중요합니다.
    - 둘째, 입력 데이터의 여러 부분을 고려하여 복잡한 해시함수를 사용하는 것이 충돌을 최소화할 수 있습니다.

  
- Hash table에서 collision이 발생하면 어떻게 되나요? 해결방법엔 뭐가 있을까요?
  - collisioin이 발생한 경우 대표적으로 2가지 방법으로 해결합니다.
  - 첫번째, open addressing방식은 collision이 발생하면 미리 정한 규칙에 따라 비어있는 해시테이블에 데이터를 저장하는 방식입니다. 빈slot을 찾는 방법에 따라 크게 Linear Probing, Quardratic Probing, Double Hasing으로 나뉩니다.
  - 두 번째, separate chaining은linked list를 이용해 충돌이 발생하면 노드를 추가해 데이터를 저장합니다.
 

- 해싱이 무엇인가요?
  - 해싱은 해시 함수에서 해시를 출력하고, 해시 테이블에 저장하는 과정까지의 행위를 말합니다.


- Hash 충돌이 잦은 경우 어떻게 하면 좋을까?
  - 우선 해시테이블이 아닌 다른 자료구조를 사용할 수 있나 찾아볼 것이고, 해시 테이블을 사용해야한다면 해시 함수가 적절한지 확인할 수 있습니다. 또는 해시 테이블이 75%이상 차 있다면 테이블을 확장해볼 수 있습니다. 해시 충돌이 잦은 경우 효율적으로 해시 테이블을 사용하려면 separate chaining에서 링크드 리스트가 아닌 Tree를 사용함으로써 최악의 경우에도 O(logN)의 시간을 보장하도록 할 수 있습니다.


- Separate chaining 장단점
  - 테이블 확장을 늦출 수 있고, 구현이 간단하다는 장점이 있지만, 추가 메모리를 사용해야하고 조회 성능이 O(1)보다 안좋아진다는 단점이 있습니다. 
  - 최악인 경우 n개의 모든 key가 동일한 해시값을 갖게 되면 길이가 n인 링크드 리스트가 생성되게 되고, 검색과 삭제에 있어 O(n)의 시간 복잡도를 갖게 됩니다.


-  Java에서는 어떤 방법으로 해시충돌을 해결하는지 아시나요?
   - jdk7까지는 linked list를 사용한 separate chaning을 활용. 
   - jdk8에서 linked list와 red black tree를 혼용한 separate chaining을 활용합니다.
   - 충돌을 한 key-value쌍이 적을때는 linked list로 작동을 합니다.반대로 충돌을 한 key-value쌍이 특정 임계치에 도달하면 red black tree로 작동을 합니다.


- Separate Chaining 해결방안 중 연결리스트를 이용한 방법과 레드블랙트리를 이용한 방법에 대한 시간복잡도 비교해주세요.
  - 링크드 리스트는 탐색하는데  O(n)의  시간복잡도를.  red black tree는 O(log n)의 시간 복잡도를 가집니다.
  
## 이진탐색
- 이진탐색에 대해 설명해주세요.
  - 이진탐색은 이미 정렬된 배열에서 특정한 값을 찾아내는 알고리즘입니다.  범위를 새로 정할 때마다 탐색 범위가 1/2씩 줄기 때문에 O(logN)의 시간복잡도를 갖습니다. 그래서 데이터 양이 많을 경우에도 빠른 시간 내에 값을 찾을 수 있어 많이 활용되고 있습니다.

- 이진탐색의 장점에 대해 설명해주세요
  > 이진탐색은 검색이 반복될 때마다 검색 범위가 절반으로 줄어들기 때문에 검색 속도가 빠릅니다. 또한 검색 대상의 크기와 상관없이 빠른 검색 속도를 제공하기 때문에 대량의 데이터를 다루는 알고리즘에서도 많이 사용됩니다.

- 이진탐색의 단점에 대해 설명해주세요
  > 배열이나 이진 탐색 트리와 같이 정렬된 구조에서만 사용이 가능합니다.

## 완전탐색
- BFS와 DFS은 장단점은? (작성자 : 이영은)
    - DFS는 스택에 백트래킹을 해야하는 노드들만 저장해주면 되기에 BFS에 비해 저장 공간의 필요성이 적고, 찾아야 하는 노드가 깊이 있을 때 빨리 탐색이 가능합니다. 하지만 답이 아닌 깊은 경로에 빠질 수 있고, 찾은 해가 최단 경로라는 보장이 없습니다.
    - BFS는 답이 되는 경로가 여러 개인 경우에도 항상 최적 해를 찾음을 보장하고, 찾아야 하는 노드가 얕을 때 유리합니다. 하지만 큐에 다음에 탐색할 노드를 계속 저장하기에 더 큰 저장공간이 필요합니다.

  
- 완전탐색에 대해 설명해주세요.
  - 완전탐색은 모든 가능한 경우의 수를 탐색하여 최적의 결과를 찾는 방법을 말합니다. 방법에는 브루트포스, 비트마스크, 백트래킹, 순열탐색, 재귀함수, 깊이우선탐색, 너비 우선탐색이 있습니다.
 
- 브루트 포스에 대해 설명해주세요
  > for문이나 while문 등의 반복문과 if문을 사요아형 모든 경우의 수를 탐색하는 완전탐색 알고리즘입니다. 모든 경우의 수를 탐색하기 때문에 경우의 수가 많아질수록 시간이 오래 걸린다는 단점을 지닙니다.

- 백트래킹에 대해 설명해주세요
  > 결과를 얻기 위해 탐색하는 도중에 막히게 되면 그 지점으로 다시 돌아가서 다른 경로를 탐색하는 알고리즘으로 재귀 함수를 활용합니다. 재귀 함수를 사용하기 때문에 오베플로우가 발생할 가능성이 있습니다.
  
## 그리디 알고리즘

- 그리디 알고리즘에 대해 설명해주세요
  > 미래에 대한 생각없이 각 단계에서 최적이라고 생각되는 것을 선택하는 알고리즘입니다. 선택 절차, 적절성 검사, 해답 검사 단계를 통해 진행합니다.

- 그리디 알고리즘의 종류에 대해 설명해주세요
    > 그리디 알고리즘 종류에는 Prime, Kruskal, Dijkstra 등이 있습니다. Prime은 정점을 중심으로 N개의 노드에 대한 최소 신장 트리를 찾습니다. Kruskal은 간선을 중심으로 N개의 노드에 대한 최소 신장 트리를 찾습니다. Dijkstra는 방문하지 않은 노드 중 가장 비용이 적은 노드를 선택합니다.

- 크루스칼 알고리즘에 대해 설명해주세요 (작성자 : 이영은)
    - 그리디 알고리즘의 하나로 모든 간선에 대해 정렬을 수행한 뒤, 가장 거리가 짧은 간선부터 집합에 포함시킵니다. 이 때, 사이클을 발생시킬 수 있는 간선의 경우 집합에 포함시키지 않습니다. 시간복잡도는 간선 개수가 E일 때, O(ElogE)를 갖습니다.


- 다익스트라 알고리즘에 대해서 설명해 주세요.
  -다익스트라 알고리즘은 음의 가중치가 없는 그래프의 한 노드에서 각 모든 노드까지의 최단거리를 구하는 알고리즘을 말합니다.
  다익스트라 알고리즘은 그리디 알고리즘이자 다이나믹 프로그래밍 기법을 사용한 알고리즘이라고 볼 수 있고, 간선의 개수E이고,정점의 수가 V일 때 O(ElogV)의 시간 복잡도를 갖습니다.



## 동적계획법(DP)
- 동적계획법에 대해 설명해주세요 (작성자 : 이영은)
    - 주어진 문제를 풀기 위해, 문제를  여러 개의 하위 문제로 나누어 푸는 방법을 말합니다.
    - 동적계획법에서는 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 답을 여러 번 계산하는 대신 한 번만 계산하고, 그 결과를 재활용하는 메모이제이션 기법으로 속도를 향상시킬 수 있습니다.

- 동적계획법의 조건에 대해 설명해주세요
  > 동적 계획법은 겹치는 부분 문제가 있어야 하며 부분 문제의 최적 결과를 통해 전체 문제의 최적 결과를 낼 수 있는 최적 부분 구조여야 합니다.

- 동적 계획법을 구현하는 방법 2가지에 대해 설명해주세요
  > 작은 부분 문제부터 차례대로 해결하여 전체 문제를 해결하는 방식인 Bottom-Up이 있으며, 문제를 작은 부분 문제들로 나누고 중복 계산을 피하기 위해 이전에 계산한 값을 저장하는 Memoization 방법이 있습니다.

-  DP와 분할 정복의 공통점과 차이점이 무엇인가요? 
   - DP와 분할 정복은 모두 문제를 잘게 나누어서, 가장 작은 단위로 분할하여 문제를 해결하는 알고리즘입니다. 
    - 하지만 DP는 부분문제가 중복되어 재활용되므로 Memoization이 필요하지만 분할정복에서는 부분 문제가 서로 중복되지 않습니다.

📚  출처

- [https://pinopino.tistory.com/entry/알고리즘-면접-대비-질문-리스트업](https://pinopino.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%A9%B4%EC%A0%91-%EB%8C%80%EB%B9%84-%EC%A7%88%EB%AC%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%97%85)
- https://dev-coco.tistory.com/160
  
