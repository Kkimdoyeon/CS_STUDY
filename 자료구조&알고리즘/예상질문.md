# 자료구조&알고리즘 면접 예상질문 

## 스택과 큐
- 스택과 큐의 구조에 대해 설명해주세요 (작성자 : 이영은)
    - Stack과 Queue는 선형 자료구조의 일종이며, Array와 LinkedList로 구현할 수 있습니다.
    - Stack은 후입선출, LIFO방식으로, 나중에 들어간 원소가 먼저 나오는 구조이고,
    - Queue는 선입선출, FIFO방식으로, 먼저 들어간 원소가 먼저 나오는 구조를 갖습니다.

- Stack과 Queue의 실사용 예를 설명해주세요 (작성자 : 이영은)
    - 먼저 Stack은 자바의 Stack메모리 영역을 예시로 설명하겠습니다. 지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메소드 호출 시 메모리에 할당되고 종료되면 메모리가 해제되며 LIFO구조를 갖습니다.
    - Queue는 OS의 스케줄러를 예시로 설명하겠습니다. 자원의 할당과 회수를 하는 스케줄러 역할을 큐가 할 수 있습니다. 메모리에 적재된 다수의 프로세스 중 어떤 프로세스에게 자원을 할당할 것인가 그 순서를 결정하는 것이 자원의 효율적인 사용에 있고, 가장 단순한 형태의 스케줄링 정책이 선입선출, 큐라고 볼 수 있습니다.

- 우선순위 큐에 대해 설명해주세요 (작성자 : 이영은)
    - 우선순위 큐는 들어간 순서에 상관없이 우선순위가 높은 데이터를 먼저 꺼내기 위해 고안된 자료구조입니다.
    - 우선순위 큐 구현방식에는 배열, 연결리스트, 힙이 있고, 그 중 힙방식이 worst case라 시간 복잡도 O(logN)을 보장하기에 일반적으로 완전 이진트리 형태의 힙을 이용해 구현합니다.

- Stack과 Queue, Deque에 대해서 설명해주세요 (작성자 : 이가연)

    - 스택은 후입선출 (LIFO) 구조를 가지는 자료 구조입니다. 즉, 마지막에 추가된 요소가 가장 먼저 제거됩니다. 주요 연산으로는 Push Pop이 있습니다.

    - 큐는 선입선 (FIFO) 구조를 가지는 자료 구조입니다. 즉, 가장 먼저 추가된 요소가 가장 먼저 제거됩니다. 주요 연산으로는 Enqueue와 Dequeue가 있습니다.
    - 덱은 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료 구조입니다. 주요 연산으로는 양쪽 끝에서의 Enqueue와 Dequeue가 있습니다.

- Stack과 Queue의 실사용 예시가 있을까요? (작성자 : 이가연)

    - 스택의 실사용 예시로는 브라우저의 뒤로가기, 실행 취소 등이 있습니다.

    - 큐의 실사용 예시로는 프린터, 작업의 우선순위 대기열 등이 있습니다.

- 우선순위 큐가 무엇인지, 내부 구조 및 시간복잡도에 대해 설명해주세요. (작성자 : 이가연)

    - 우선순위 큐란 각 요소에 우선순위를 할당하고, 우선순위가 높은 요소가 먼저 처리되는 자료 구조입니다.

    - 주요 연산으로는 삽입, 삭제, 최대/최소 우선순위 요소 찾기 등이 있습니다.

    - 내부 구조는 힙(Heap)을 주로 사용합니다. 이진 힙(Binary Heap)이 가장 일반적으로 사용됩니다.

    - 시간복잡도는 삽입과 삭제 연산이 O(log n)이며, 최대/최소 우선순위 요소 찾기는 O(1)입니다.

## 연결리스트

- Array와 ArrayList의 차이점에 대해 설명해주세요. (작성자 : 이영은)
    - Array는 크기가 고정적이고, ArrayList는 크기가 가변적입니다.
    - Array는 초기화 시 메모리에 할당되어 ArrayList보다 속도가 빠르고, ArrayList는 데이터 추가 및 삭제 시 메모리를 재할당하기 때문에 속도가 Array보다 느립니다.

- Array와 LinkedList의 장 / 단점에 대해 설명해주세요. (작성자 : 이영은)
    - Array는 인덱스로 해당 원소에 접근할 수 있어 찾고자 하는 원소의 인덱스 값을 알고 있으면 O(1)에 해당 원소로 접근할 수 있습니다. 즉 RandomAccess가 가능해 속도가 빠르다는 장점이 있습니다. 하지만 삽입 또는 삭제의 과정에서 각 원소들을 이동해줘야 하는 비용이 생겨 이 경우 시간복잡도는 O(n)이 된다는 단점이 있습니다.
    - 이 문제점을 해결하기 위한 자료구조가 LinkedList입니다. 각각의 원소들은 자기 자신 다음에 어떤 원소인지만을 기억하고 있기 때문에 이 부분만 다른 값으로 바꿔주면 삽입과 삭제를 O(1)으로 해결할 수 있습니다. 하지만 LinkedList는 원하는 위치에 한 번에 접근할 수 없다는 단점이 있습니다. 원하는 위치에 삽입을 하고자 하면 원하는 위치를 Search과정에 있어서 첫번째 원소부터 다 확인해봐야 합니다.
    - 간단히 정리하면, Array는 검색이 빠르지만, 삽입과 삭제가 느립니다. LinkedList는 삽입과 삭제는 빠르지만, 검색이 느립니다.

- 연결 리스트란 무엇이며, 어떤 장점이나 단점이 있는지 설명해보세요. (작성자 : 이가연)

    - 연결 리스트는 데이터 요소들을 노드로 나타내고, 각 노드는 데이터와 다음 노드를 가리키는 포인터로 이루어진 자료 구조입니다.

    - 장점으로는 삽입과 삭제가 O(1)로 배열보다 효율적이지만, 단점으로는 특정 위치의 데이터에 접근하는 데에는 순차적으로 접근해야 하므로 O(n) 시간이 소요돼 비효율적입니다.

- 연결리스트와 배열의 차이점에 대해 설명해보세요. (작성자 : 이가연)

    - 연결 리스트는 동적 할당으로 삽입과 삭제가 O(1) 시간이 소요돼 빠르지만 접근은 O(n) 시간이 소요돼 비효율적입니다.

    - 반대로 배열은 정적 할당으로 삽입과 삭제가 O(n) 시간이 소요돼 비효율적이지만 접근은 O(1) 시간이 소요돼 효율적입니다.

- 연결 리스트에서 중간에 노드를 삽입하거나 삭제하는 방법에 대해 설명해보세요. (작성자 : 이가연)

    - 중간에 노드를 삽입하려면 삽입 위치 이전의 노드가 가리키는 노드를 새로운 노드가 가리키게 한 뒤 이전 노드는 새로운 노드를 가리키게 하면 됩니다.

    - 중간에 노드를 삭제하려면 삭제하려는 노드의 이전 노드가 가리키는 포인터를 삭제하려는 노드의 다음 노드로 설정하면 됩니다.   

- 연결 리스트 세 종류에 대해 설명해주세요 (작성자 : 강도경)
    - 첫번쨰, 단순 연결 리스트 입니다. 단순 연결 리스트는 하나의 방향으로만 연결되어 있는 연결 리스트입니다. 하나의 링크 필드를 가지며, 이 링크 필드를 이용하여 모든 노드들이 연결되어 있습니다. (체인이라고도 함) 마지막 노드의 링크 필드는 NULL값을 가집니다. 
    - 두번째, 원형 연결 리스트입니다. 단순 연결 리스트와 같으나 마지막 노드가 첫 번째 노드를 가리킵니다. 마지막 노드의 링크 필드는 첫번째 노드 주소를 가리킵니다. 하나의 노드에서 다른 모든 노드로 접근이 가능합니다. 원소가 하나 밖에 없으면 자기자신을 가리킵니다. 
    - 세번째, 이중 연결 리스트입니다. 각 노드마다 2개의 링크가 존재합니다. 하나의 링크는 앞의 노드를 가리키고 다른 하나의 노드는 뒤의 노드를 가리킵니다. 단순 연결 리스트의 단점을 보완하여 특정 노드에서 자유롭게 양방향으로 움직일 수 있습니다.


## 트리

- BST(BinarySearchTree) 와 Binary Tree에 대해 설명해주세요 (작성자 : 이영은)
    - 이진트리는 자식노드가 최대 두 개인 노드들로 구성된 트리이고, 이진탐색트리는 이진 탐색과 연결 리스트를 결합한 자료구조 입니다.
    - 이진 탐색의효율적인 탐색 능력을 유지하면서, 빈번한 자료 입력과 삭제가 가능하닫는 장점이 있습니다.
    - 이진 탐색 트리는 왼쪽 트리의 모든 값은 반드시 부모 노드보다 작아야 하고, 오른쪽 트리의 값은 부모 노드보다 커야하는 특징이 있습니다.
    - 이진 탐색 트리의 탐색 연산은 트리의 높이에 영향을 받아 높이가 h일때 시간 복잡도는 O(h)이며, 트리의 균형이 한쪽으로 치우쳐진 경우 worst case가 되고 O(n)의 시간 복잡도를 가집니다. 이런 worst case를 막기 위해 나온 기법이 RBT(Red-Black Tree) 입니다.

- RBT(Red-Black Tree)에 대해 설명해주세요 (작성자 : 이영은)
    - RBT(Red-Black Tree)는 BST를 기반으로 하는 트리 형식 자료구조이며, RBT는 BST의 삽입, 삭제 연산 과정에서 발생할 수 있는 문제점을 해결하기 위해 만들어졌습니다.
    - BST를 기반으로 하기 때문에 당연히 BST의 특징을 모두 갖습니다.
    - 노드의 자식이 없는 경우, 자식을 가리키는 포인터는 NIL값을 저장합니다. 이러한 NIL들을 leaf node로 간주합니다.
    - 모든 노드를 빨간색 또는 검은색으로 색칠하며, 연결된 노드들은 색이 중복되지 않습니다.

- 트리(Tree)란 무엇인가요? (작성자 : 이가연)
    - 트리는 계층적인 구조를 가지며, 각 노드가 하나 이상의 자식 노드를 가질 수 있는 비선형 자료 구조입니다.
    - 트리는 루트(root), 노드(node), 에지(edge), 리프(leaf) 등의 용어로 설명됩니다.

- 이진 트리(Binary Tree)와 이진 탐색 트리(Binary Search Tree)의 차이는 무엇인가요? (작성자 : 이가연)
    - 이진 트리는 각 노드가 최대 두 개의 자식 노드를 가지는 트리이며, 이진 탐색 트리는 이진 트리의 일종으로 왼쪽 자식은 현재 노드보다 작은 값, 오른쪽 자식은 현재 노드보다 큰 값이라는 규칙을 따르는 트리입니다.

- 트리의 순회 방법에는 어떤 것들이 있으며, 각각 어떤 시나리오에서 사용될까요? (작성자 : 이가연)
    - 주요 순회 방법에는 전위 순회(pre-order), 중위 순회(in-order), 후위 순회(post-order)가 있습니다. 전위 순회는 복사 → 왼쪽 서브트리 순서로, 중위 순회는 왼쪽 서브트리 → 복사 → 오른쪽 서브트리 순서로, 후위 순회는 왼쪽 서브트리 → 오른쪽 서브트리 → 복사 순서로 순회합니다.

- 힙(Heap)이란 무엇이며, 어떤 상황에서 사용되나요? (작성자 : 이가연)
    - 힙은 최댓값 또는 최솟값을 빠르게 찾기 위한 자료구조로, 주로 우선순위 큐를 구현하는 데 사용됩니다. 최대 힙은 부모 노드가 자식 노드보다 크거나 같고, 최소 힙은 부모 노드가 자식 노드보다 작거나 같은 이진 트리입니다.

- 밸런스드 트리(Balanced Tree)와 언밸런스드 트리(Unbalanced Tree)의 차이는 무엇인가요? (작성자 : 이가연)
    - 밸런스드 트리는 트리의 높이가 일정하게 유지되어 검색, 삽입, 삭제 연산이 항상 일정한 시간 복잡도(O(logn))를 가지는 트리입니다.

    - 언밸런스드 트리는 트리의 높이가 크게 차이나는 경우로, 이 경우에는 성능이 저하될 수 있습니다.

- 트리와 그래프의 차이는 무엇인가요? (작성자 : 이가연)
    - 트리는 사이클이 없는 연결된 그래프의 특별한 형태이며, 계층적인 구조를 가집니다.
    - 그래프는 정점과 간선의 집합으로 이루어져 있으며, 트리는 그래프의 일종입니다. 그래프에는 방향성이 없는 무방향 그래프와 방향성이 있는 방향 그래프가 있습니다.


## 그래프

- 깊이 우선 탐색과 너비 우선 탐색의 설명과 차이점에 대해 설명해주세요 (작성자 : 이영은)
    - DFS와 BFS는 모두 그래프를 탐색하는 방법입니다.
    - DFS는 루트 노드 정점에서 시작해서 다음 간선으로 가기 전에 해당 간선을 완벽하게 탐색하는 방식입니다. BFS는 루트 노드 정점에서 시작해서 인접한 노드부터 먼저 탐색하는 방법으로 시작 정점부터 가까운 정점을 먼저 탐색하고 멀리 떨어져 있는 정점을 나중에 탐색하는 방식입니다.
    - 차이점은 검색 속도 차이, 구현방식, 탐색 대상 그래프 규모에 따른 활용도 정도 있습니다. 검색 속도 차이에서는 BFS가 조금 더 빠릅니다. 하지만 경로마다 특징을 저장해둬야 하는 경우 DFS를 사용하고, 최단거리를 구하는 방식은 BFS가 조금 더 유리합니다.
    - DFS는 스택 또는 재귀함수로 구현하고, BFS는 큐를 이용해서 구현합니다.

- 그래프의 구현 방법에는 어떤 방법이 있는지 장단점과 함께 설명하고 어떤 경우에 무슨 방법을 쓰는 것이 유리한지도 설명해주세요. (작성자 : 이가연)
    - 그래프의 구현 방법에는 크게 인접행렬과 인접리스트 두 가지 방법이 있습니다.
    - 인접행렬은 2차원배열로 그래프의 연결유무와 가중치를 표현한 방법으로 간선의 추가 및 삭제, 연결유무 확인에 O(1)이라는 짧은 시간이 듭니다.
    - 단 노드와 간선이 적은 희소 그래프의 경우 배열에 남는 공간이 많아 메모리 낭비가 심하고 생성에 O(V^2)라는 비효율적인 시간이 소요됩니다.
    - 인접리스트는 각 정점에 연결된 정점들을 연결 리스트로 구현한 방법으로 필요한 공간만 사용하기 때문에 메모리 소요가 적습니다.
    - 단 간선의 추가 및 삭제, 구현이 인접행렬에 비해 비효율적이기 때문에 노드와 간선이 많은 밀집 그래프의 경우에는 적합하지 않습니다.
    - 따라서 밀집그래프의 경우 인접행렬을, 희소그래프의 경우 인접리스트를 사용하는 것이 메모리의 낭비를 최소화하고 작업 시간을 줄이는데 유리합니다.

- 그래프의 종류에 대해 설명해주세요. (작성자 : 이가연)
    - 그래프에는 무방향 그래프, 노드와의 방향을 나타내는 방향 그래프, 간선에 가중치가 존재하는 가중 그래프, 모든 노드가 간선으로 연결된 완전 그래프가 있습니다.


## 힙

- 자료구조와 알고리즘에 대해 설명해주세요. (작성자 : 이영은)
    - 자료구조는 데이터를 원하는 규칙 또는 목적에 맞게 저장하기 위한 구조이고, 알고리즘이란 자료구조에 쌓인 데이터를 활용해 어떠한 문제를 해결하기 위한 여러 동작들의 모임입니다.

- 트리와 힙의 구조에 대해 설명해주세요. (작성자 : 이영은)
    - 트리는 스택과 큐와 같은 선형 구조가 아닌 비선형 자료구조이며, 계층적 관계를 표현하기에 적합합니다.
    - 힙은 최댓값 또는 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 구조로, 각 노드의 키 값이 자식의 키 값보다 작지 않거나(최대힙) 그 자식의 키 값보다 크지 않은(최소힙) 완전 이진 트리입니다.

- 힙의 구조에 대해 설명해주세요. (작성자 : 이가연)
    - 힙은 최소값과 최대값을 쉽게 찾기 위해 구상된 완전이진트리로, 최소 힙은 부모노드가 항상 자식노드보다 작으며 최대 힙은 부모노드가 항상 자식노드보다 큰 특징을 지닙니다.

- 힙의 삽입과 삭제 과정을 시간복잡도와 함께 설명해주세요. (작성자 : 이가연)
    - 힙의 삽입은 삽입할 노드를 마지막에 위치시키고 부모노드와 비교하며 힙의 특성을 만족시킬 때까지 위치를 조정하는 방식으로 진행됩니다.
    - 힙의 삭제는 항상 루트 노드에서 일어납니다.
    - 루트 노드를 제거한 뒤 마지막 노드를 루트로 올리고 힙의 특성을 만족시킬 때까지 자식노드와 비교하며 위치를 조정합니다.
    - 힙의 삽입과 삭제 과정은 항상 힙의 높이와 비례하므로 O(logn) 시간이 소요됩니다.

- 힙의 종류에 대해 설명해주세요. (작성자 : 강도경)
    - 최대힙과 최소힙이 있습니다.
    - 최대힙은 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리입니다. 
    - 최소힙은 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리입니다.

- 힙을 배열로 구현하는 이유를 설명해주세요. (작성자 : 허민영)
    - 힙을 저장하는 표준적인 자료구조는 배열입니다. 프로그램 구현을 쉽게 하기 위해 배열의 첫번째 인덱스인 0은 사용되지 않습니다. 배열을 이용하여 힙을 저장하면 완전 이진 트리에서 처럼 자식 노드와 부모 노드를 쉽게 알 수 있습니다.

## 정렬

- 버블 정렬에 대해 설명해주세요

  > 배열의 인접한 두 원소를 비교해 위치를 조정하며 최대값 맨뒤로 보낸 뒤 <br>정렬되지 않은 나머지 배열에 대해 정렬이 완료될 때까지 반복하는 알고리즘입니다.<br>
  > 시간 복잡도는 최선/최악의 경우 모두 O(n^2)로 비효율적인 알고리즘입니다.
- 선택 정렬에 대해 설명해주세요
  > 배열에서 최대값을 뽑아 맨 뒤로 보낸 뒤 <br>정렬되지 않은 나머지 배열에 대해 정렬이 완료될 때까지 반복하는 알고리즘입니다.<br>
  > 시간 복잡도는 최선/최악의 경우 모두 O(n^2)로 비효율적인 알고리즘입니다.
- 삽입 정렬에 대해 설명해주세요
  > 정렬된 배열과 정렬되지 않은 배열로 나누어 <br>정렬되지 않은 배열의 원소를 차례차례 정렬된 배열의 올바른 위치에 삽입하는 알고리즘입니다.<br>
  > 시간 복잡도는 최선의 경우 O(n)이고 최악의 경우 O(n^2)로 배열이 정렬돼있을수록 효율적인 알고리즘입니다.
- 병합 정렬에 대해 설명해주세요
  > 부분 배열의 크기가 1이 될 때까지 분할한 뒤 부분 리스트를 재귀적으로 병합하는 알고리즘입니다.<br>
  > 시간 복잡도는 최선/최악의 경우 모두 O(nlogn)이나 병합을 위한 추가 배열의 메모리가 소요됩니다.
- 퀵 정렬에 대해 설명해주세요
  > 피벗을 지정해 이를 기준으로 재귀적으로 정렬하는알고리즘입니다. <br>이때 피벗이 두 개인 정렬을 듀얼 피벗 알고리즘이라 합니다.<br>
  > 시간 복잡도는 최선/최악의 경우 모두 O(nlogn)으로 항상 효율적인 알고리즘입니다.
- 힙 정렬에 대해 설명해주세요
  > 배열이 정렬될 때까지 힙으로 만들고 루트를 꺼내 저장을 반복하는 알고리즘입니다.<br>
  > 시간 복잡도는 최선/최악의 경우 모두 O(nlogn)으로 항상 효율적인 알고리즘이며 <br>특히 가장 큰 값 몇 개를 꺼낼 때 유용합니다.
  
- 계수 정렬에 대해 설명해주세요
  > 각 숫자가 몇 개 있는지 개수를 세어 저장한 후 정렬하는 알고리즘입니다.
  > 정렬하고자하는 배열의 최댓값을 구한 후 최댓값 크기의 배열에 각 원소를 순회하며 해당 값이 몇 개인지 저장하고 저장된 데이터를 순서대로 출력합니다.
  
- 왜 삽입 정렬이 평균 O(N^2) 시간 복잡도를 갖는 알고리즘들 중에서 가장 빠를가요?
  >삽입 정렬은 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘입니다. 따라서 삽입할 위치까지만 탐색하면 되기 때문에 선택 정렬과 버블정렬에 비해 빠릅니다.
  또한 이미 정렬이 된 경우 한번씩만 비교하면 되므로 O(N)시간 복잡도를 갖습니다.

- Quick Sort의 특징과 시간복잡도에 대해 설명해주세요.
  >퀵소트는 기준 데이터 pivot을 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꿔 정렬하는 알고리즘입니다. 추가적인 메모리를 필요로하지 않습니다. 시간복잡도의 경우 피봇이 정확히 데이터를 절반씩 나눈다면 평균적으로 O(NlogN)에 정렬이 가능하지만, 피봇이 데이터를 1개씩만 나눈다면 최악의 경우 시간복잡도는 O(N^2)가 됩니다.

- Quick Sort 성능 개선 기법으로는 어떤게 있나요?
  > 3가지 방법을 알고있습니다. 하나는 피복을 맨 처음 값으로 하면 최악의 경우 O(N^2)의 시간 복잡도를 가지므로 랜덤으로 피봇을 설정하도록 하는 것입니다.
  또는 맨 앞과 중간 맨 뒤 값을 우선적으로 정렬하고 중앙값을 피봇으로 삼는 경우입니다.
  마지막으로는 삽입정렬과 함께 사용하는 방법입니다. 만약 배열의 크기가 특정 수 이하라면 삽입정렬, 특정 수보다 크면 퀵정렬을 사용하여 정렬하는 방식입니다.
  퀵소트는 거의 정렬된 상태에서 성능이 매우 떨어진다는 점을 고려해 정렬된 배열에서 좋은 성능을 발휘하는 삽입정렬을 사용하면 어느정도 성능 하락을 방지할 수 있습니다.

- 54321 배열이 있을 때, 어떤 정렬을 사용하면 좋을까요?
  > 이미 내림차순으로 정렬되어 있기 때문에, 사용 목적에 따라 인덱스를 역순으로 접근하면 가장 시간적 효율이 높다고 생각합니다.
  그럼에도 정렬을 해야 한다면, 가장 빠른 시간복잡도로 알려진 힙 정렬이나 병합 정렬을 사용할 것 같습니다.

- 정렬을 하는 이유는 무엇인가요?
  >데이터를 탐색하기 위해서 합니다. 정렬이 되어있다면 이진탐색을 할 수 있기 때문입니다.

- 랜덤으로 배치된 배열이 있을때, 어떤 정렬을 사용하면 좋을까요
  > 배열의 상태에 구애받지 않고 일정한 시간 복잡도를 가진 힙 정렬이나 병합 정렬을 사용할 것 같습니다.

- 언제 불안정 정렬을 쓰면 안될까요?
  > 기존의 정렬을 유지해야할 때 입니다.
  > A,B 쌍인데 B는 이미 정렬상태로 입력되는 상황이 벌어지면 기존의 정렬이 깨지기 떄문입니다.

- 자릿수가 모두 같은 수가 담긴 배열이 있을 때, 어떤 정렬을 사용하면 좋을까요?
  > 공간 복잡도가 높아지기는 하지만, 기수 정렬을 사용하는 것이 시간적으로 효율이 가장 높다고 생각합니다. 
  > 기수 정렬은 일의 자리부터 순서대로 자릿수 별로 버킷에 담는 방식으로, 
  > 최대 자릿수 만큼만 반복하면 되기 떄문에 빠르게 정렬이 가능합니다.



## 해시
- 해시테이블과 시간복잡도에 대해 설명해주세요
    - 해시테이블은 키와 밸류의 쌍 형태로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조입니다.
    - 빠른 검색 속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문입니다.
    - 각 키값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 O(1)의 시간 복잡도로 데이터를 조회합니다. 하지만 index값이 충돌이 발생한 경우 Chaninging에 연결된 리스트들까지 검색해야 하므로 O(N)까지 증가할 수 있습니다.


- 해시 맵과 해시 테이블의 차이점에 대해 설명해주세요
    - 동기화 지원 여부와 null값 허용 여부의 차이가 있습니다.
    - 해시테이블은 병렬처리를 할 때, 즉 동기화를 고려해야 하는 상황에서 Thread-safe합니다. 또한 null값을 허용하지 않습니다.
    - 해시맵은 병렬처리를 하지 않을 때, 즉 동기화를 고려하지 않는 상황일 때 Thread-safr 하지 않으며, null값을 허용합니다.


- 값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?
    - 충돌이 최대한 적은 해시 함수를 설계하기 위해서는 두가지 방법이 있습니다.
    - 첫째, 입력 데이터의 가능한 모든 값 범위를 고려하여 해시 함수의 출력 범위를 균등하게 분포시키는 것이 중요합니다.
    - 둘째, 입력 데이터의 여러 부분을 고려하여 복잡한 해시함수를 사용하는 것이 충돌을 최소화할 수 있습니다.

  
- Hash table에서 collision이 발생하면 어떻게 되나요? 해결방법엔 뭐가 있을까요?
  - collisioin이 발생한 경우 대표적으로 2가지 방법으로 해결합니다.
  - 첫번째, open addressing방식은 collision이 발생하면 미리 정한 규칙에 따라 비어있는 해시테이블에 데이터를 저장하는 방식입니다. 빈slot을 찾는 방법에 따라 크게 Linear Probing, Quardratic Probing, Double Hasing으로 나뉩니다.
  - 두 번째, separate chaining은linked list를 이용해 충돌이 발생하면 노드를 추가해 데이터를 저장합니다.
 

- 해싱이 무엇인가요?
  - 해싱은 해시 함수에서 해시를 출력하고, 해시 테이블에 저장하는 과정까지의 행위를 말합니다.


- Hash 충돌이 잦은 경우 어떻게 하면 좋을까?
  - 우선 해시테이블이 아닌 다른 자료구조를 사용할 수 있나 찾아볼 것이고, 해시 테이블을 사용해야한다면 해시 함수가 적절한지 확인할 수 있습니다. 또는 해시 테이블이 75%이상 차 있다면 테이블을 확장해볼 수 있습니다. 해시 충돌이 잦은 경우 효율적으로 해시 테이블을 사용하려면 separate chaining에서 링크드 리스트가 아닌 Tree를 사용함으로써 최악의 경우에도 O(logN)의 시간을 보장하도록 할 수 있습니다.


- Separate chaining 장단점
  - 테이블 확장을 늦출 수 있고, 구현이 간단하다는 장점이 있지만, 추가 메모리를 사용해야하고 조회 성능이 O(1)보다 안좋아진다는 단점이 있습니다. 
  - 최악인 경우 n개의 모든 key가 동일한 해시값을 갖게 되면 길이가 n인 링크드 리스트가 생성되게 되고, 검색과 삭제에 있어 O(n)의 시간 복잡도를 갖게 됩니다.


-  Java에서는 어떤 방법으로 해시충돌을 해결하는지 아시나요?
   - jdk7까지는 linked list를 사용한 separate chaning을 활용. 
   - jdk8에서 linked list와 red black tree를 혼용한 separate chaining을 활용합니다.
   - 충돌을 한 key-value쌍이 적을때는 linked list로 작동을 합니다.반대로 충돌을 한 key-value쌍이 특정 임계치에 도달하면 red black tree로 작동을 합니다.


- Separate Chaining 해결방안 중 연결리스트를 이용한 방법과 레드블랙트리를 이용한 방법에 대한 시간복잡도 비교해주세요.
  - 링크드 리스트는 탐색하는데  O(n)의  시간복잡도를.  red black tree는 O(log n)의 시간 복잡도를 가집니다.
  
## 이진탐색
- 이진탐색에 대해 설명해주세요.
  - 이진탐색은 이미 정렬된 배열에서 특정한 값을 찾아내는 알고리즘입니다.  범위를 새로 정할 때마다 탐색 범위가 1/2씩 줄기 때문에 O(logN)의 시간복잡도를 갖습니다. 그래서 데이터 양이 많을 경우에도 빠른 시간 내에 값을 찾을 수 있어 많이 활용되고 있습니다.

- 이진탐색의 장점에 대해 설명해주세요
  > 이진탐색은 검색이 반복될 때마다 검색 범위가 절반으로 줄어들기 때문에 검색 속도가 빠릅니다. 또한 검색 대상의 크기와 상관없이 빠른 검색 속도를 제공하기 때문에 대량의 데이터를 다루는 알고리즘에서도 많이 사용됩니다.

- 이진탐색의 단점에 대해 설명해주세요
  > 배열이나 이진 탐색 트리와 같이 정렬된 구조에서만 사용이 가능합니다.

## 완전탐색
- BFS와 DFS은 장단점은? (작성자 : 이영은)
    - DFS는 스택에 백트래킹을 해야하는 노드들만 저장해주면 되기에 BFS에 비해 저장 공간의 필요성이 적고, 찾아야 하는 노드가 깊이 있을 때 빨리 탐색이 가능합니다. 하지만 답이 아닌 깊은 경로에 빠질 수 있고, 찾은 해가 최단 경로라는 보장이 없습니다.
    - BFS는 답이 되는 경로가 여러 개인 경우에도 항상 최적 해를 찾음을 보장하고, 찾아야 하는 노드가 얕을 때 유리합니다. 하지만 큐에 다음에 탐색할 노드를 계속 저장하기에 더 큰 저장공간이 필요합니다.

  
- 완전탐색에 대해 설명해주세요.
  - 완전탐색은 모든 가능한 경우의 수를 탐색하여 최적의 결과를 찾는 방법을 말합니다. 방법에는 브루트포스, 비트마스크, 백트래킹, 순열탐색, 재귀함수, 깊이우선탐색, 너비 우선탐색이 있습니다.
 
- 브루트 포스에 대해 설명해주세요
  > for문이나 while문 등의 반복문과 if문을 사요아형 모든 경우의 수를 탐색하는 완전탐색 알고리즘입니다. 모든 경우의 수를 탐색하기 때문에 경우의 수가 많아질수록 시간이 오래 걸린다는 단점을 지닙니다.

- 백트래킹에 대해 설명해주세요
  > 결과를 얻기 위해 탐색하는 도중에 막히게 되면 그 지점으로 다시 돌아가서 다른 경로를 탐색하는 알고리즘으로 재귀 함수를 활용합니다. 재귀 함수를 사용하기 때문에 오베플로우가 발생할 가능성이 있습니다.
  
## 그리디 알고리즘

- 그리디 알고리즘에 대해 설명해주세요
  > 미래에 대한 생각없이 각 단계에서 최적이라고 생각되는 것을 선택하는 알고리즘입니다. 선택 절차, 적절성 검사, 해답 검사 단계를 통해 진행합니다.

- 그리디 알고리즘의 종류에 대해 설명해주세요
    > 그리디 알고리즘 종류에는 Prime, Kruskal, Dijkstra 등이 있습니다. Prime은 정점을 중심으로 N개의 노드에 대한 최소 신장 트리를 찾습니다. Kruskal은 간선을 중심으로 N개의 노드에 대한 최소 신장 트리를 찾습니다. Dijkstra는 방문하지 않은 노드 중 가장 비용이 적은 노드를 선택합니다.

- 크루스칼 알고리즘에 대해 설명해주세요 (작성자 : 이영은)
    - 그리디 알고리즘의 하나로 모든 간선에 대해 정렬을 수행한 뒤, 가장 거리가 짧은 간선부터 집합에 포함시킵니다. 이 때, 사이클을 발생시킬 수 있는 간선의 경우 집합에 포함시키지 않습니다. 시간복잡도는 간선 개수가 E일 때, O(ElogE)를 갖습니다.


- 다익스트라 알고리즘에 대해서 설명해 주세요.
  -다익스트라 알고리즘은 음의 가중치가 없는 그래프의 한 노드에서 각 모든 노드까지의 최단거리를 구하는 알고리즘을 말합니다.
  다익스트라 알고리즘은 그리디 알고리즘이자 다이나믹 프로그래밍 기법을 사용한 알고리즘이라고 볼 수 있고, 간선의 개수E이고,정점의 수가 V일 때 O(ElogV)의 시간 복잡도를 갖습니다.



## 동적계획법(DP)
- 동적계획법에 대해 설명해주세요 (작성자 : 이영은)
    - 주어진 문제를 풀기 위해, 문제를  여러 개의 하위 문제로 나누어 푸는 방법을 말합니다.
    - 동적계획법에서는 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 답을 여러 번 계산하는 대신 한 번만 계산하고, 그 결과를 재활용하는 메모이제이션 기법으로 속도를 향상시킬 수 있습니다.

- 동적계획법의 조건에 대해 설명해주세요
  > 동적 계획법은 겹치는 부분 문제가 있어야 하며 부분 문제의 최적 결과를 통해 전체 문제의 최적 결과를 낼 수 있는 최적 부분 구조여야 합니다.

- 동적 계획법을 구현하는 방법 2가지에 대해 설명해주세요
  > 작은 부분 문제부터 차례대로 해결하여 전체 문제를 해결하는 방식인 Bottom-Up이 있으며, 문제를 작은 부분 문제들로 나누고 중복 계산을 피하기 위해 이전에 계산한 값을 저장하는 Memoization 방법이 있습니다.

-  DP와 분할 정복의 공통점과 차이점이 무엇인가요? 
   - DP와 분할 정복은 모두 문제를 잘게 나누어서, 가장 작은 단위로 분할하여 문제를 해결하는 알고리즘입니다. 
    - 하지만 DP는 부분문제가 중복되어 재활용되므로 Memoization이 필요하지만 분할정복에서는 부분 문제가 서로 중복되지 않습니다.

📚  출처

- https://code-lab1.tistory.com/2

- https://hyeinisfree.tistory.com/64

- [https://pinopino.tistory.com/entry/알고리즘-면접-대비-질문-리스트업](https://pinopino.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%A9%B4%EC%A0%91-%EB%8C%80%EB%B9%84-%EC%A7%88%EB%AC%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%97%85)
- https://dev-coco.tistory.com/160
  
