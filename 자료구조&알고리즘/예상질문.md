# 자료구조&알고리즘 면접 예상질문 

## 정렬

- 버블 정렬에 대해 설명해주세요

  > 배열의 인접한 두 원소를 비교해 위치를 조정하며 최대값 맨뒤로 보낸 뒤 <br>정렬되지 않은 나머지 배열에 대해 정렬이 완료될 때까지 반복하는 알고리즘입니다.<br>
  > 시간 복잡도는 최선/최악의 경우 모두 O(n^2)로 비효율적인 알고리즘입니다.
- 선택 정렬에 대해 설명해주세요
  > 배열에서 최대값을 뽑아 맨 뒤로 보낸 뒤 <br>정렬되지 않은 나머지 배열에 대해 정렬이 완료될 때까지 반복하는 알고리즘입니다.<br>
  > 시간 복잡도는 최선/최악의 경우 모두 O(n^2)로 비효율적인 알고리즘입니다.
- 삽입 정렬에 대해 설명해주세요
  > 정렬된 배열과 정렬되지 않은 배열로 나누어 <br>정렬되지 않은 배열의 원소를 차례차례 정렬된 배열의 올바른 위치에 삽입하는 알고리즘입니다.<br>
  > 시간 복잡도는 최선의 경우 O(n)이고 최악의 경우 O(n^2)로 배열이 정렬돼있을수록 효율적인 알고리즘입니다.
- 병합 정렬에 대해 설명해주세요
  > 부분 배열의 크기가 1이 될 때까지 분할한 뒤 부분 리스트를 재귀적으로 병합하는 알고리즘입니다.<br>
  > 시간 복잡도는 최선/최악의 경우 모두 O(nlogn)이나 병합을 위한 추가 배열의 메모리가 소요됩니다.
- 퀵 정렬에 대해 설명해주세요
  > 피벗을 지정해 이를 기준으로 재귀적으로 정렬하는알고리즘입니다. <br>이때 피벗이 두 개인 정렬을 듀얼 피벗 알고리즘이라 합니다.<br>
  > 시간 복잡도는 최선/최악의 경우 모두 O(nlogn)으로 항상 효율적인 알고리즘입니다.
- 힙 정렬에 대해 설명해주세요
  > 배열이 정렬될 때까지 힙으로 만들고 루트를 꺼내 저장을 반복하는 알고리즘입니다.<br>
  > 시간 복잡도는 최선/최악의 경우 모두 O(nlogn)으로 항상 효율적인 알고리즘이며 <br>특히 가장 큰 값 몇 개를 꺼낼 때 유용합니다.

## 해시
- 해시테이블과 시간복잡도에 대해 설명해주세요
    - 해시테이블은 키와 밸류의 쌍 형태로 데이터를 저장하는 자료구조 중 하나로 빠르게 데이터를 검색할 수 있는 자료구조입니다.
    - 빠른 검색 속도를 제공하는 이유는 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문입니다.
    - 각 키값은 해시함수에 의해 고유한 index를 가지게 되어 바로 접근할 수 있으므로 평균 O(1)의 시간 복잡도로 데이터를 조회합니다. 하지만 index값이 충돌이 발생한 경우 Chaninging에 연결된 리스트들까지 검색해야 하므로 O(N)까지 증가할 수 있습니다.
- 해시 맵과 해시 테이블의 차이점에 대해 설명해주세요
    - 동기화 지원 여부와 null값 허용 여부의 차이가 있습니다.
    - 해시테이블은 병렬처리를 할 때, 즉 동기화를 고려해야 하는 상황에서 Thread-safe합니다. 또한 null값을 허용하지 않습니다.
    - 해시맵은 병렬처리를 하지 않을 때, 즉 동기화를 고려하지 않는 상황일 때 Thread-safr 하지 않으며, null값을 허용합니다.
- 값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?
    - 충돌이 최대한 적은 해시 함수를 설계하기 위해서는 두가지 방법이 있습니다.
    - 첫째, 입력 데이터의 가능한 모든 값 범위를 고려하여 해시 함수의 출력 범위를 균등하게 분포시키는 것이 중요합니다.
    - 둘째, 입력 데이터의 여러 부분을 고려하여 복잡한 해시함수를 사용하는 것이 충돌을 최소화할 수 있습니다.

- Hash table에서 collision이 발생하면 어떻게 되나요? 해결방법엔 뭐가 있을까요?
  - collisioin이 발생한 경우 대표적으로 2가지 방법으로 해결합니다.
  - 첫번째, open addressing방식은 collision이 발생하면 미리 정한 규칙에 따라 비어있는 해시테이블에 데이터를 저장하는 방식입니다. 빈slot을 찾는 방법에 따라 크게 Linear Probing, Quardratic Probing, Double Hasing으로 나뉩니다.
  - 두 번째, separate chaining은linked list를 이용해 충돌이 발생하면 노드를 추가해 데이터를 저장합니다.
 
- 해싱이 무엇인가요?
  - 해싱은 해시 함수에서 해시를 출력하고, 해시 테이블에 저장하는 과정까지의 행위를 말합니다.

- Hash 충돌이 잦은 경우 어떻게 하면 좋을까?
  - 우선 해시테이블이 아닌 다른 자료구조를 사용할 수 있나 찾아볼 것이고, 해시 테이블을 사용해야한다면 해시 함수가 적절한지 확인할 수 있습니다. 또는 해시 테이블이 75%이상 차 있다면 테이블을 확장해볼 수 있습니다. 해시 충돌이 잦은 경우 효율적으로 해시 테이블을 사용하려면 separate chaining에서 링크드 리스트가 아닌 Tree를 사용함으로써 최악의 경우에도 O(logN)의 시간을 보장하도록 할 수 있습니다.

## 이진탐색

## 완전탐색
- BFS와 DFS은 장단점은? (작성자 : 이영은)
    - DFS는 스택에 백트래킹을 해야하는 노드들만 저장해주면 되기에 BFS에 비해 저장 공간의 필요성이 적고, 찾아야 하는 노드가 깊이 있을 때 빨리 탐색이 가능합니다. 하지만 답이 아닌 깊은 경로에 빠질 수 있고, 찾은 해가 최단 경로라는 보장이 없습니다.
    - BFS는 답이 되는 경로가 여러 개인 경우에도 항상 최적 해를 찾음을 보장하고, 찾아야 하는 노드가 얕을 때 유리합니다. 하지만 큐에 다음에 탐색할 노드를 계속 저장하기에 더 큰 저장공간이 필요합니다.

## 그리디 알고리즘
- 크루스칼 알고리즘에 대해 설명해주세요 (작성자 : 이영은)
    - 그리디 알고리즘의 하나로 모든 간선에 대해 정렬을 수행한 뒤, 가장 거리가 짧은 간선부터 집합에 포함시킵니다. 이 때, 사이클을 발생시킬 수 있는 간선의 경우 집합에 포함시키지 않습니다. 시간복잡도는 간선 개수가 E일 때, O(ElogE)를 갖습니다.
## 동적계획법(DP)
- 동적계획법에 대해 설명해주세요 (작성자 : 이영은)
    - 주어진 문제를 풀기 위해, 문제를  여러 개의 하위 문제로 나누어 푸는 방법을 말합니다.
    - 동적계획법에서는 어떤 부분 문제가 다른 문제들을 해결하는데 사용될 수 있어, 답을 여러 번 계산하는 대신 한 번만 계산하고, 그 결과를 재활용하는 메모이제이션 기법으로 속도를 향상시킬 수 있습니다.



📚  출처

- [https://pinopino.tistory.com/entry/알고리즘-면접-대비-질문-리스트업](https://pinopino.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%A9%B4%EC%A0%91-%EB%8C%80%EB%B9%84-%EC%A7%88%EB%AC%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%97%85)
- https://dev-coco.tistory.com/160
  