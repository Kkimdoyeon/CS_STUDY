# 정렬

## 정렬 종류
- 버블 정렬
- 선택 정렬
- 삽입 정렬
- 병합 정렬
- 퀵 정렬
- 힙 정렬

### 버블 정렬

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/cc507c1b-3195-4e0d-acb2-a782de69bdbf)

배열을 순회하며 인접한 두 원소끼리 비교해 순서를 바꿔나간다.

순회가 종료되면 마지막 요소(가장 큰 값)을 제외하고 정렬이 완료될 때까지 위 단계를 반복한다.

**시간복잡도**

최선/최악: **O(n^2)**

이중 반복문을 사용하기 때문에 비효율적이다. 

### 선택 정렬

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/ebe65578-474f-47cd-9036-24a13a2b280e)

배열에서 최소값을 찾아 맨 앞으로 보낸 후 정렬되지 않은 나머지 부분에서 해당 과정을 반복하는 방법이다.

**시간복잡도**

최선/최악: **O(n^2)**

이중 반복문을 사용하기 때문에 비효율적이다. 

### 삽입 정렬

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/f5f3f715-8bc3-4da8-816a-45cfc6a25289)

배열을 정렬된 배열과 정렬되지 않은 배열로 나눈다. 이 때 초기 전자의 배열은 배열 첫번째 원소이다. (원소가 1개인 배열은 항상 정렬이기 때문)

정렬되지 않은 배열의 첫번째 원소를 정렬된 배열의 적절한 위치에 삽입하며 정렬이 완료될 때까지 정렬 배열을 늘려나간다. 

**시간복잡도**

최선: **O(n)** (정렬시)
최악: **O(n^2)**

이중 반복문을 사용하기 때문에 비효율적이지만 정렬에 가까울 수록 효율적인 시간을 낸다.

### 병합 정렬

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/315cfde7-874a-472b-ad16-852eb50165d2)

분할 정복법을 사용한 정렬이다. 

부분 리스트의 길이가 1이 될 때까지 절반씩 나눈 후 부분 리스트를 재귀적으로 정렬해 병합한다. 

병합을 위한 추가 리스트가 필요하다.

**시간 복잡도**

최선/최악: **O(nlogn)**

재귀를 사용해 안정적이고 효율적이지만, 추가 배열 공간 메모리가 소요된다.

### 퀵 정렬
![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/69cf427a-64f4-46ba-9bf7-8a897bbf130b)

피벗을 활용한 분할 정복법 정렬이다.

중심점을 피벗으로 지정하고 이를 기준으로 양쪽의 배열을 재귀적으로 정렬한다.

**시간 복잡도**

최선:**O(nlogn)** (피벗이 배열을 균등하게 분할)

최악:**O(n^2)** (피벗이 항상 최소/최대일 때)

### 힙 정렬

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/03396039-a6aa-4126-9470-8ac65722d81e)

힙 자료구조를 사용한 정렬 방법이다.

배열을 재귀적으로 heapify하며 최대/최소인 루트를 꺼내 정렬한다.

**시간 복잡도**

최선/최악:**O(nlogn)**

항상 효율적인 성능을 내 좋은 정렬 알고리즘이다.












