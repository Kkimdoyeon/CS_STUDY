# 완전탐색

![image](https://github.com/dlrkdus/CS_STUDY/assets/99721126/0a5191b8-50ae-4baa-b590-b0ea4525d61d)

완전탐색(Exhaustive Search)은 가능한 모든 경우의 수를 탐색하여 원하는 결과를 찾는 알고리즘이다.

## 브루트포스
모든 가능한 해를 하나씩 검사하는 방식이다. <br>
문제의 규모나 해의 개수가 적을 효과적이지만 대체로 시간복잡도가 높은 비효율적인 알고리즘이다.

## 비트마스크
비트 연산을 이용하여 부분집합, 순열, 조합 등을 표현하고 관리하는 방식이다.<br>
집합 문제에서 유용하게 사용한다.

## 재귀함수
재귀적 호출을 통해 문제를 해결하는 방식이다.<br>
문제를 작은 부분 문제로 분할하여 해결하고, 이를 조합하여 전체 문제의 해를 얻는다.

**구현**
```
def factorial(n):
    # 종료 조건
    if n == 0 or n == 1:
        return 1
    # 재귀 호출
    else:
        return n * factorial(n - 1)
```

## 백트래킹
가능한 모든 후보군을 검사하다가 현재의 후보군에서 해를 찾을 수 없으면 **이전 단계로 돌아가서** 다른 후보군을 검사하는 방식이다.<br>
여러 문제에서 제약 조건을 만족하는 해를 찾을 때 활용된다.

## 순열 탐색
원소들을 순열이나 조합으로 나열하여 문제를 해결하는 방식이다.
순서를 고려하면 순열, 고려하지 않으면 조합이다. 이때 순열은 백트래킹을 사용한다.

## DFS&BFS
비선형 구조 탐색의 두 가지 방법으로 깊이 우선 탐색과 너비 우선 탐색이 있다. <br>

**다음은 백트래킹과 DFS를 사용한 순열탐색 코드이다**

```
# m개의 원소 중에서 n개 뽑기 
arr = [1,2,3...m] #m개의 배열
tmp = [0]*n  #뽑은 원소를 저장하는 임시 배열, n개 뽑을거니 크기는 n
visited= [0]*m #중복을 허용하지 않는 순열 특성상 방문한 노드는 다시 방문하지 않기 위해 방문 기록용 배열

def dfs(level):
    if level== n: #n개를 다 뽑았다면
        print(*tmp) #임시배열 출력
        return #현재 호출을 종료하고 이전 호출로 돌아가게 한다. 
    for i in range(m): #m개의 원소를 돌면서
        if visited[i] == 0:  #아직 방문하지 않았다면
            visited[i] = 1  #방문 기록
            tmp[level] = arr[i]  #뽑은 원소 임시배열에 저장
            dfs(level+1)  #다음 원소 뽑기
            visited[i] = 0  #방문 기록 초기화(다음 순열을 위해)
            tmp[level] = 0  # 뽑은 원소 초기화
dfs(0)

```
